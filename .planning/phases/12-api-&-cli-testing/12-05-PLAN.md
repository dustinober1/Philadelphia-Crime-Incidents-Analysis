---
phase: 12-api-&-cli-testing
plan: 05
type: execute
wave: 2
depends_on: ["12-01", "12-02", "12-03", "12-04"]
files_modified:
  - tests/test_api_services.py
autonomous: true

must_haves:
  truths:
    - "load_all_data() successfully loads JSON and GeoJSON files"
    - "get_data() returns cached data and raises KeyError for missing keys"
    - "contract_status() correctly reports data contract health"
    - "cache_keys() returns list of loaded cache keys"
    - "Error handling for missing files and invalid data directory is tested"
  artifacts:
    - path: "tests/test_api_services.py"
      provides: "Unit tests for API service layer (data_loader.py)"
      min_lines: 200
  key_links:
    - from: "tests/test_api_services.py"
      to: "api/services/data_loader.py"
      via: "direct import and monkeypatch"
      pattern: "from api\.services\.data_loader import"
---

<objective>
Write unit tests for the API service layer (api/services/data_loader.py) using pytest and monkeypatch.

Purpose: Ensure the data loading service layer is tested with mocked file I/O for fast execution. This provides coverage for the service layer logic without loading real data files.

Output: New test file tests/test_api_services.py with comprehensive service layer tests.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/12-api-&-cli-testing/12-RESEARCH.md
@.planning/phases/11-core-module-testing/11-05-SUMMARY.md
@api/services/data_loader.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test file and add load_all_data() tests</name>
  <files>tests/test_api_services.py</files>
  <action>
Create tests/test_api_services.py and add tests for load_all_data():

1. **test_load_all_data_populates_cache()**
   - Use tmp_path to create test data directory
   - Create test JSON files (test.json with {"key": "value"})
   - Create test GeoJSON files (geo/test.geojson with valid GeoJSON)
   - Call load_all_data(data_dir=tmp_path)
   - Verify _DATA_CACHE is populated with expected keys
   - Verify cache contains parsed JSON (not strings)

2. **test_load_all_data_clears_existing_cache()**
   - Pre-populate _DATA_CACHE with old data
   - Call load_all_data() with new test directory
   - Verify old cache keys are removed
   - Verify only new data is in cache

3. **test_load_all_data_only_json_and_geojson()**
   - Create directory with .txt, .csv, .json, .geojson files
   - Call load_all_data()
   - Verify only .json and .geojson files are loaded
   - Verify .txt and .csv files are ignored

Use tmp_path fixture for isolated test directories.
Use monkeypatch to avoid loading real data.
  </action>
  <verify>Run pytest tests/test_api_services.py -v -k "load_all_data" and verify all tests pass</verify>
  <done>load_all_data() is tested with file type filtering, cache population, and cache clearing</done>
</task>

<task type="auto">
  <name>Task 2: Add get_data() tests</name>
  <files>tests/test_api_services.py</files>
  <action>
Add tests for get_data() function:

1. **test_get_data_returns_cached_value()**
   - Pre-populate _DATA_CACHE with test data using monkeypatch
   - Call get_data("test.json")
   - Verify correct data is returned

2. **test_get_data_raises_key_error_for_missing()**
   - Set _DATA_CACHE to empty dict using monkeypatch
   - Call get_data("nonexistent.json")
   - Verify KeyError is raised with message "Data key not loaded"

3. **test_get_data_with_geojson_key()**
   - Pre-populate _DATA_CACHE with GeoJSON data
   - Call get_data("geo/districts.geojson")
   - Verify GeoJSON dict is returned with correct structure

Pattern: Use monkeypatch.setattr("api.services.data_loader._DATA_CACHE", mock_data).
  </action>
  <verify>Run pytest tests/test_api_services.py -v -k "get_data" and verify all tests pass</verify>
  <done>get_data() is tested for happy path and missing key error case</done>
</task>

<task type="auto">
  <name>Task 3: Add contract_status() and cache_keys() tests</name>
  <files>tests/test_api_services.py</files>
  <action>
Add tests for contract_status() and cache_keys():

1. **test_contract_status_ok_when_all_files_present()**
   - Use tmp_path with all REQUIRED_EXPORTS files
   - Call contract_status(data_dir=tmp_path)
   - Verify "ok" is True
   - Verify "missing_exports" is empty list
   - Verify "data_dir" is correct path

2. **test_contract_status_not_ok_when_files_missing()**
   - Use tmp_path with only some required files
   - Call contract_status(data_dir=tmp_path)
   - Verify "ok" is False
   - Verify "missing_exports" lists missing files
   - Verify "data_dir" is correct path

3. **test_contract_status_nonexistent_directory()**
   - Call contract_status(data_dir=Path("/nonexistent/path"))
   - Verify "ok" is False
   - Verify "missing_exports" contains all REQUIRED_EXPORTS

4. **test_cache_keys_returns_sorted_list()**
   - Pre-populate _DATA_CACHE with multiple keys
   - Call cache_keys()
   - Verify result is a list
   - Verify result is sorted alphabetically
   - Verify all cache keys are present

5. **test_cache_keys_empty_when_cache_empty()**
   - Set _DATA_CACHE to empty dict
   - Call cache_keys()
   - Verify result is empty list

Use tmp_path for file system operations.
  </action>
  <verify>Run pytest tests/test_api_services.py -v -k "contract_status or cache_keys" and verify all tests pass</verify>
  <done>contract_status() and cache_keys() are tested for all code paths</done>
</task>

<task type="auto">
  <name>Task 4: Add _validate_data_contract() error handling tests</name>
  <files>tests/test_api_services.py</files>
  <action>
Add tests for _validate_data_contract() error cases:

1. **test_validate_data_contract_raises_on_missing_directory()**
   - Call _validate_data_contract(Path("/nonexistent"))
   - Verify RuntimeError is raised
   - Verify error message mentions "API data directory does not exist"

2. **test_validate_data_contract_raises_on_missing_exports()**
   - Use tmp_path without required export files
   - Call _validate_data_contract(tmp_path)
   - Verify RuntimeError is raised
   - Verify error message lists missing exports

3. **test_validate_data_contract_passes_with_complete_exports()**
   - Use tmp_path with all REQUIRED_EXPORTS
   - Call _validate_data_contract(tmp_path)
   - Verify no exception is raised

Use pytest.raises for exception testing.
Use monkeypatch to set up test directories.
  </action>
  <verify>Run pytest tests/test_api_services.py -v -k "validate" and verify all tests pass</verify>
  <done>_validate_data_contract() error handling is fully tested</done>
</task>

<task type="auto">
  <name>Task 5: Add API_DATA_DIR environment variable tests</name>
  <files>tests/test_api_services.py</files>
  <action>
Add tests for API_DATA_DIR environment variable handling:

1. **test_resolve_data_dir_uses_env_var_when_set()**
   - Set API_DATA_DIR using monkeypatch.setenv
   - Call _resolve_data_dir()
   - Verify returns path from environment variable

2. **test_resolve_data_dir_uses_default_when_env_not_set()**
   - Ensure API_DATA_DIR is not set
   - Call _resolve_data_dir()
   - Verify returns default DATA_DIR

3. **test_load_all_data_uses_data_dir_from_env()**
   - Set API_DATA_DIR to tmp_path
   - Create test files in tmp_path
   - Call load_all_data()
   - Verify files from tmp_path are loaded (not default DATA_DIR)

Use monkeypatch.setenv("API_DATA_DIR", str(tmp_path)).
  </action>
  <verify>Run pytest tests/test_api_services.py -v -k "env or data_dir" and verify all tests pass</verify>
  <done>API_DATA_DIR environment variable handling is tested</done>
</task>

</tasks>

<verification>
After completion, verify:
1. Run pytest tests/test_api_services.py -v and count passing tests
2. All functions in data_loader.py have tests (load_all_data, get_data, contract_status, cache_keys, _validate_data_contract, _resolve_data_dir)
3. At least 15 new service layer tests pass
4. Coverage for api/services/data_loader.py is 85%+
5. All tests use monkeypatch for isolation and fast execution
</verification>

<success_criteria>
1. New test file tests/test_api_services.py is created
2. All service layer functions have unit tests
3. File I/O is mocked using tmp_path and monkeypatch
4. Error handling paths are tested (missing files, invalid directory, missing cache keys)
5. Tests run in under 2 seconds (no real data loading)
</success_criteria>

<output>
After completion, create .planning/phases/12-api-&-cli-testing/12-05-SUMMARY.md with:
- Number of tests added for service layer
- Coverage percentage for api/services/data_loader.py
- Any edge cases discovered during testing
</output>
