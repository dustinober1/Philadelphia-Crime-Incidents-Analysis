---
phase: 11-core-module-testing
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - tests/test_utils_spatial.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "tests/test_utils_spatial.py exists with comprehensive tests"
    - "All functions in utils/spatial.py have test coverage"
    - "Tests mock GeoPandas operations to avoid slow spatial joins"
    - "Tests use synthetic coordinate data"
  artifacts:
    - path: "tests/test_utils_spatial.py"
      provides: "Unit tests for spatial utilities"
      min_lines: 500
      exports: ["TestCleanCoordinates", "TestLoadBoundaries", "TestDfToGeodataframe", "TestSpatialJoinDistricts", "TestSpatialJoinTracts", "TestCalculateSeverityScore", "TestGetCoordinateStats"]
  key_links:
    - from: "tests/test_utils_spatial.py"
      to: "analysis/utils/spatial.py"
      via: "import and function call testing"
      pattern: "from analysis.utils.spatial import"
---

<objective>
Create comprehensive unit tests for utils/spatial.py covering coordinate cleaning, boundary loading, GeoDataFrame conversion, spatial joins for districts and tracts, severity scoring, and coordinate statistics.

**Purpose:** Ensure spatial utilities are tested with mocked GeoPandas operations. Test coordinate filtering, severity score calculation, and spatial join logic.

**Output:** test_utils_spatial.py with 50-60 tests using synthetic coordinate data and mocked GeoPandas.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/11-core-module-testing/11-RESEARCH.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Lock honored decisions from Phase 10
- pytest-xdist: Use -nauto for local development
- Branch coverage: Set branch=true
- Testing priority: High-priority modules (data processing, validation, utilities) first

# Reference existing patterns
@tests/conftest.py
@tests/test_data_validation.py
@tests/test_temporal.py
</context>

<tasks>

<task type="auto">
  <name>Create test_utils_spatial.py with coordinate cleaning tests</name>
  <files>tests/test_utils_spatial.py</files>
  <action>
    Create tests/test_utils_spatial.py with the following test structure:

    **Class TestCleanCoordinates:**
    - test_filters_valid_philadelphia_coordinates: Verify only coordinates in Philly bounds returned
    - test_filters_out_nan_coordinates: Verify rows with NaN in point_x or point_y removed
    - test_filters_out_out_of_bounds_lon: Verify longitude < -75.3 or > -74.95 filtered out
    - test_filters_out_out_of_bounds_lat: Verify latitude < 39.85 or > 40.15 filtered out
    - test_custom_x_col_parameter: Verify x_col parameter works for custom longitude column
    - test_custom_y_col_parameter: Verify y_col parameter works for custom latitude column
    - test_missing_columns_raises_value_error: Verify ValueError when x_col or y_col not in DataFrame
    - test_returns_copy_not_view: Verify returned DataFrame is a copy (modifications don't affect original)
    - test_preserves_original_columns: Verify all original columns preserved in output
    - test_handles_empty_dataframe: Verify empty DataFrame returns empty result
    - test_all_invalid_returns_empty: Verify DataFrame with all invalid coordinates returns empty

    Philly bounds from config:
    - Longitude: PHILLY_LON_MIN=-75.3, PHILLY_LON_MAX=-74.95
    - Latitude: PHILLY_LAT_MIN=39.85, PHILLY_LAT_MAX=40.15

    Use @pytest.mark.parametrize for boundary value testing.
  </action>
  <verify>pytest tests/test_utils_spatial.py::TestCleanCoordinates -v</verify>
  <done>11 tests pass for coordinate cleaning</done>
</task>

<task type="auto">
  <name>Add severity score and coordinate statistics tests</name>
  <files>tests/test_utils_spatial.py</files>
  <action>
    Add the following test classes to test_utils_spatial.py:

    **Class TestCalculateSeverityScore:**
    - test_ucr_100_band_returns_10_severity: Verify UCR 100-199 maps to severity 10.0
    - test_ucr_200_band_returns_8_severity: Verify UCR 200-299 maps to severity 8.0
    - test_ucr_300_band_returns_6_severity: Verify UCR 300-399 maps to severity 6.0
    - test_ucr_400_band_returns_5_severity: Verify UCR 400-499 maps to severity 5.0
    - test_ucr_500_band_returns_3_severity: Verify UCR 500-599 maps to severity 3.0
    - test_ucr_600_band_returns_1_severity: Verify UCR 600-699 maps to severity 1.0
    - test_ucr_700_band_returns_2_severity: Verify UCR 700-799 maps to severity 2.0
    - test_ucr_800_band_returns_4_severity: Verify UCR 800-899 maps to severity 4.0
    - test_unknown_ucr_defaults_to_0_5: Verify UCR codes outside known bands default to 0.5
    - test_custom_weights_override_defaults: Verify custom weights dict overrides defaults
    - test_nan_ucr_code_returns_nan: Verify NaN UCR code results in NaN severity
    - test_custom_ucr_col_parameter: Verify ucr_col parameter works for custom column name
    - test_missing_ucr_col_raises_value_error: Verify ValueError when ucr_col not in DataFrame
    - test_returns_series: Verify returns pd.Series with same length as input DataFrame

    **Class TestGetCoordinateStats:**
    - test_returns_dict_with_expected_keys: Verify has 'total_records', 'has_coordinates', 'in_philadelphia_bounds', 'coverage_rate', 'in_bounds_rate', 'lon_min', 'lon_max', 'lat_min', 'lat_max'
    - test_total_records_matches_input_length: Verify total_records == len(df)
    - test_has_coordinates_counts_valid_coords: Verify has_coordinates counts rows with non-NaN coordinates
    - test_in_philadelphia_bounds_counts_valid_coords: Verify counts coordinates in Philly bounds
    - test_coverage_rate_calculation: Verify coverage_rate = has_coordinates / total_records
    - test_in_bounds_rate_calculation: Verify in_bounds_rate = in_philadelphia_bounds / total_records
    - test_lon_min_max_calculations: Verify min/max longitude computed correctly
    - test_lat_min_max_calculations: Verify min/max latitude computed correctly
    - test_empty_dataframe_returns_zero_stats: Verify empty DataFrame has total_records=0, rates=0
    - test_custom_x_col_y_col_parameters: Verify custom column names work
    - test_all_nan_coordinates_returns_zero_coverage: Verify all-NaN coordinates give coverage_rate=0

    Use sample DataFrames with synthetic UCR codes and coordinates.
  </action>
  <verify>pytest tests/test_utils_spatial.py::TestCalculateSeverityScore tests/test_utils_spatial.py::TestGetCoordinateStats -v</verify>
  <done>25 tests pass for severity scoring and coordinate statistics</done>
</task>

<task type="auto">
  <name>Add GeoDataFrame conversion and boundary loading tests</name>
  <files>tests/test_utils_spatial.py</files>
  <action>
    Add the following test classes to test_utils_spatial.py:

    **Class TestDfToGeodataframe:**
    - test_returns_geodataframe: Verify returns gpd.GeoDataFrame
    - test_geometry_column_created: Verify 'geometry' column with Point objects created
    - test_default_crs_is_epsg_4326: Verify default CRS is EPSG:4326 (WGS84)
    - test_custom_crs_parameter: Verify custom CRS parameter works
    - test_nan_coordinates_create_none_geometry: Verify NaN coordinates result in None geometry
    - test_custom_x_col_y_col_parameters: Verify custom column names work
    - test_preserves_original_columns: Verify all original columns preserved in output

    **Class TestLoadBoundaries:**
    - test_load_police_districts_returns_geodataframe: Verify returns gpd.GeoDataFrame
    - test_load_census_tracts_returns_geodataframe: Verify returns gpd.GeoDataFrame
    - test_load_census_tracts_pop_alias: Verify 'census_tracts_pop' alias works
    - test_unknown_boundary_raises_value_error: Verify ValueError for unknown boundary name
    - test_file_not_found_raises_file_not_found_error: Verify FileNotFoundError when boundary file missing
    - test_mock_file_path_uses_repo_root: Verify file path constructed from repo root

    For df_to_geodataframe tests, use small DataFrames with valid coordinates. For load_boundaries tests, use unittest.mock.patch to mock gpd.read_file and Path.exists.
  </action>
  <verify>pytest tests/test_utils_spatial.py::TestDfToGeodataframe tests/test_utils_spatial.py::TestLoadBoundaries -v</verify>
  <done>12 tests pass for GeoDataFrame conversion and boundary loading</done>
</task>

<task type="auto">
  <name>Add spatial join tests with mocked GeoPandas</name>
  <files>tests/test_utils_spatial.py</files>
  <action>
    Add the following test classes to test_utils_spatial.py:

    **Class TestSpatialJoinDistricts:**
    - test_returns_dataframe_with_joined_dist_num: Verify adds 'joined_dist_num' column
    - test_calls_clean_coordinates_internally: Verify coordinate cleaning happens before join
    - test_calls_df_to_geodataframe_internally: Verify conversion to GeoDataFrame happens
    - test_drops_index_right_column: Verify 'index_right' cleanup column removed
    - test_drops_geometry_column: Verify 'geometry' column removed from output
    - test_custom_x_col_y_col_parameters: Verify custom column names work
    - test_provided_district_gdf_used: Verify custom district_gdf parameter used when provided
    - test_handles_crs_mismatch: Verify CRS conversion when district_gdf.crs != crime_gdf.crs

    **Class TestSpatialJoinTracts:**
    - test_returns_dataframe_with_tract_columns: Verify adds 'GEOID' and/or 'total_pop' columns
    - test_calls_clean_coordinates_internally: Verify coordinate cleaning happens before join
    - test_calls_df_to_geodataframe_internally: Verify conversion to GeoDataFrame happens
    - test_drops_index_right_column: Verify 'index_right' cleanup column removed
    - test_drops_geometry_column: Verify 'geometry' column removed from output
    - test_custom_x_col_y_col_parameters: Verify custom column names work
    - test_provided_tract_gdf_used: Verify custom tract_gdf parameter used when provided
    - test_handles_crs_mismatch: Verify CRS conversion when tract_gdf.crs != crime_gdf.crs
    - test_handles_missing_tract_columns: Verify only available columns selected from tract_gdf

    Mock geopandas.sjoin to return predetermined results. Create mock GeoDataFrame with 'dist_num', 'GEOID', 'total_pop', 'geometry' columns.
  </action>
  <verify>pytest tests/test_utils_spatial.py::TestSpatialJoinDistricts tests/test_utils_spatial.py::TestSpatialJoinTracts -v</verify>
  <done>17 tests pass for spatial joins</done>
</task>

<task type="auto">
  <name>Run coverage report for utils/spatial.py</name>
  <files>tests/test_utils_spatial.py</files>
  <action>
    Run pytest with coverage to verify utils/spatial.py achieves target coverage:

    ```bash
    pytest tests/test_utils_spatial.py --cov=analysis.utils.spatial --cov-report=term-missing --cov-report=html
    ```

    Target: 80%+ coverage for utils/spatial.py (from research baseline).

    If coverage is below 80%, identify missing branches and add targeted tests:
    - Check for untested error paths (ValueError for missing columns, FileNotFoundError)
    - Check for edge cases (all NaN coordinates, empty DataFrames, CRS mismatches)
    - Check for optional parameter combinations (custom column names, custom GeoDataFrames)

    Document final coverage percentage in plan summary.
  </action>
  <verify>pytest tests/test_utils_spatial.py --cov=analysis.utils.spatial --cov-report=term-missing</verify>
  <done>Coverage report shows 80%+ for utils/spatial.py with no critical gaps</done>
</task>

</tasks>

<verification>
- All 50-60 tests in test_utils_spatial.py pass with pytest -nauto
- Coverage report shows 80%+ coverage for utils/spatial.py
- No tests load real GeoJSON files or perform actual spatial joins
- All tests follow behavior-focused pattern from TESTING_QUALITY_CRITERIA.md
- Tests use synthetic coordinate data and mocked GeoPandas per RESEARCH.md patterns
</verification>

<success_criteria>
- test_utils_spatial.py created with 50-60 tests
- Tests cover all functions in utils/spatial.py
- 80%+ coverage achieved for utils/spatial.py
- All tests pass with pytest -nauto in under 30 seconds
- GeoPandas operations mocked to avoid slow spatial joins
</success_criteria>

<output>
After completion, create `.planning/phases/11-core-module-testing/11-04-SUMMARY.md`
</output>
