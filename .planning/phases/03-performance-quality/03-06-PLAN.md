---
phase: 03-performance-quality
plan: "06"
type: execute
wave: 1
depends_on: []
files_modified:
  - pipeline/export_data.py
  - api/routers/trends.py
  - api/data/annual_trends_district.json
  - api/data/monthly_trends_district.json
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can filter by police district (all 23 PPD districts)"
    - "District filter changes annual/monthly trend charts to show district-specific data"
    - "COVID and seasonality analyses remain citywide (inherently citywide by design)"
    - "API supports district-filtered trend endpoints for annual/monthly data"
  artifacts:
    - path: "api/routers/trends.py"
      provides: "District query param support for annual/monthly endpoints"
      contains: "district.*Query"
    - path: "api/data/annual_trends_district.json"
      provides: "District-scoped annual trend aggregates"
    - path: "api/data/monthly_trends_district.json"
      provides: "District-scoped monthly trend aggregates"
  key_links:
    - from: "api/routers/trends.py"
      to: "api/data/*_district.json"
      via: "get_data with district filtering"
      pattern: "district.*get_data"
---

<objective>
Enable district filtering for annual/monthly trend data by generating district-scoped trend aggregates and adding district query parameter support to API endpoints.

Purpose: Currently, trend data aggregates at citywide level only. Users selecting districts in the filter UI see no change in charts because TrendRow lacks district dimension. This plan fixes that by providing district-scoped data and API filtering for annual/monthly trends.

Note: COVID comparison and seasonality analyses are inherently citywide and will not support district filtering. COVID compares pandemic periods across the entire city; seasonality shows temporal patterns at citywide level. The frontend will display appropriate messaging when district filters are active but these analyses remain citywide.

Output: New district-scoped trend exports for annual/monthly data, updated API endpoints with district query param support for annual/monthly endpoints.
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key existing files
@pipeline/export_data.py
@api/routers/trends.py
@web/src/lib/api.ts
@web/src/lib/filters.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate district-scoped trend exports in pipeline</name>
  <files>pipeline/export_data.py</files>
  <action>
    Modify the `_export_trends` function to generate additional district-scoped trend files alongside the existing citywide files.

    1. Add a new section after the citywide annual/monthly exports that groups by year+month+district+crime_category:

    ```python
    # District-scoped annual trends (includes dc_dist)
    annual_district = _group_size_to_records_frame(
        categorized.groupby(["year", "crime_category", "dc_dist"], observed=False)
    ).sort_values(["year", "crime_category", "dc_dist"])
    _write_json(output_dir / "annual_trends_district.json", _to_records(annual_district))

    # District-scoped monthly trends (includes dc_dist)
    monthly_district = _group_size_to_records_frame(
        categorized.assign(
            month=categorized["dispatch_date"].dt.to_period("M").dt.to_timestamp()
        ).groupby(["month", "crime_category", "dc_dist"], observed=False)
    ).sort_values(["month", "crime_category", "dc_dist"])
    _write_json(output_dir / "monthly_trends_district.json", _to_records(monthly_district))
    ```

    2. The `dc_dist` field is the police district number (1-23). It already exists in the categorized dataframe because it's part of the raw crime data.

    3. DO NOT modify the existing annual_trends.json and monthly_trends.json exports - they remain for citywide views when no districts are selected.
  </action>
  <verify>
    ```bash
    # Run the pipeline export
    python -m pipeline.export_data --output-dir api/data

    # Verify the new files exist and have the expected structure
    python -c "
import json
annual = json.load(open('api/data/annual_trends_district.json'))
monthly = json.load(open('api/data/monthly_trends_district.json'))
print(f'Annual districts: {len(annual)} rows')
print(f'Monthly districts: {len(monthly)} rows')
print(f'Annual sample: {annual[0] if annual else {}}')
print(f'Monthly sample: {monthly[0] if monthly else {}}')
# Verify dc_dist is present
assert 'dc_dist' in annual[0], 'dc_dist missing from annual'
assert 'dc_dist' in monthly[0], 'dc_dist missing from monthly'
print('OK: district-scoped exports generated')
"
    ```
  </verify>
  <done>New files api/data/annual_trends_district.json and api/data/monthly_trends_district.json exist with dc_dist field in each row</done>
</task>

<task type="auto">
  <name>Task 2: Add district filtering to API trend endpoints</name>
  <files>api/routers/trends.py</files>
  <action>
    Update the annual and monthly endpoints to support a `district` query parameter that filters results from the district-scoped files.

    1. Add a new `district` query parameter to both endpoints:

    ```python
    @router.get("/annual")
    def annual(
        category: str | None = Query(default=None),
        district: int | None = Query(default=None, ge=1, le=23, description="PPD district number (1-23)")
    ) -> list[dict[str, Any]]:
        # If district is specified, use district-scoped data
        if district is not None:
            data = cast(list[dict[str, Any]], get_data("annual_trends_district.json"))
            data = [row for row in data if row.get("dc_dist") == district]
        else:
            data = cast(list[dict[str, Any]], get_data("annual_trends.json"))

        if category:
            data = [row for row in data if row.get("crime_category") == category]
        return data

    @router.get("/monthly")
    def monthly(
        start_year: int | None = None,
        end_year: int | None = None,
        district: int | None = Query(default=None, ge=1, le=23, description="PPD district number (1-23)")
    ) -> list[dict[str, Any]]:
        # If district is specified, use district-scoped data
        if district is not None:
            data = cast(list[dict[str, Any]], get_data("monthly_trends_district.json"))
            data = [row for row in data if row.get("dc_dist") == district]
        else:
            data = cast(list[dict[str, Any]], get_data("monthly_trends.json"))

        def _year(value: str) -> int:
            return int(value[:4])

        if start_year is not None:
            data = [row for row in data if _year(row["month"]) >= start_year]
        if end_year is not None:
            data = [row for row in data if _year(row["month"]) <= end_year]
        return data
    ```

    2. The district parameter is a single integer (not a list) to keep the API simple. The frontend will request data for the first selected district, or all districts combined if multiple are selected.

    3. Note: When multiple districts are selected in the frontend, the client will need to aggregate client-side. This is acceptable for 2-3 districts.
  </action>
  <verify>
    ```bash
    # Start the API server
    cd /Users/dustinober/Projects/Philadelphia-Crime-Incidents-Analysis

    # Test citywide annual (no district param)
    curl -s "http://localhost:8080/api/v1/trends/annual" | python -c "import json,sys; d=json.load(sys.stdin); print(f'Citywide: {len(d)} rows'); print(f'Sample: {d[0] if d else {}}')"

    # Test district-filtered annual
    curl -s "http://localhost:8080/api/v1/trends/annual?district=1" | python -c "import json,sys; d=json.load(sys.stdin); print(f'District 1: {len(d)} rows'); print(f'Sample: {d[0] if d else {}}'); assert 'dc_dist' in d[0] if d else True, 'dc_dist missing'"

    # Test district-filtered monthly
    curl -s "http://localhost:8080/api/v1/trends/monthly?district=5" | python -c "import json,sys; d=json.load(sys.stdin); print(f'District 5 monthly: {len(d)} rows')"

    echo "OK: district filtering works"
    ```
  </verify>
  <done>API endpoints accept district query parameter and return district-filtered data from district-scoped files</done>
</task>

</tasks>

<verification>
1. Pipeline generates district-scoped trend files for annual/monthly data
2. API annual/monthly endpoints return district-filtered data when district param is provided
3. API annual/monthly endpoints return citywide data when district param is absent (backward compatible)
4. District parameter validation (1-23 range)
5. COVID and seasonality endpoints remain unchanged (citywide only)
</verification>

<success_criteria>
- api/data/annual_trends_district.json exists with dc_dist field
- api/data/monthly_trends_district.json exists with dc_dist field
- GET /api/v1/trends/annual?district=1 returns only district 1 data
- GET /api/v1/trends/monthly?district=1 returns only district 1 data
- GET /api/v1/trends/annual (no district) returns citywide data (unchanged)
- GET /api/v1/trends/covid returns citywide data (unchanged)
- GET /api/v1/trends/seasonality returns citywide data (unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-quality/03-06-SUMMARY.md`
</output>
