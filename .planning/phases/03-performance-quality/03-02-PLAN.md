---
phase: 03-performance-quality
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/components/filters/AdvancedFilters.tsx
  - web/src/lib/filters.ts
  - web/src/lib/types.ts
  - web/src/hooks/useFilteredData.ts
autonomous: true

must_haves:
  truths:
    - "User can filter by date range with start and end date inputs"
    - "User can filter by police district (all 23 PPD districts)"
    - "User can filter by crime category (Violent, Property, Other)"
    - "Filters work together (all three can be active simultaneously)"
    - "Filtered data updates charts and tables in real-time"
  artifacts:
    - path: "web/src/components/filters/AdvancedFilters.tsx"
      provides: "Unified filter controls UI"
      min_lines: 80
    - path: "web/src/hooks/useFilteredData.ts"
      provides: "Client-side data filtering hook"
      exports: ["useFilteredData"]
    - path: "web/src/lib/filters.ts"
      provides: "Filter state management and utilities"
      exports: ["FilterState", "applyFilters"]
    - path: "web/src/lib/types.ts"
      provides: "Type definitions for filtering"
      contains: "FilterState|FilterOptions"
  key_links:
    - from: "web/src/components/filters/AdvancedFilters.tsx"
      to: "web/src/hooks/useFilteredData.ts"
      via: "import { useFilteredData }"
      pattern: "useFilteredData"
    - from: "web/src/hooks/useFilteredData.ts"
      to: "web/src/lib/api.ts"
      via: "SWR data hooks"
      pattern: "useAnnualTrends|useMonthlyTrends"

---

<objective>
Implement advanced client-side filtering for date range, police district, and crime type across all data views.

**Purpose:** Allow users to slice and dice crime data by time, geography, and category for targeted analysis (PERF-02).

**Output:**
- AdvancedFilters component with date range, district, and crime type controls
- useFilteredData hook for client-side data manipulation using TanStack Table patterns
- Filter state management with URL synchronization
- Applied to Trends and Map pages initially
</objective>

<execution_context>
@.claude/get-shit-done/workflows/execute-plan.md
@.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-performance-quality/03-RESEARCH.md
@.planning/codebase/CONVENTIONS.md

@web/src/lib/api.ts
@web/src/lib/types.ts
@web/src/components/DateRangeFilter.tsx
@web/src/components/tables/DataTable.tsx
@web/src/components/tables/TableFilters.tsx
@web/src/app/trends/page.tsx
@web/src/app/map/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Create filter type definitions and utilities</name>
  <files>web/src/lib/types.ts, web/src/lib/filters.ts</files>
  <action>
    1. In web/src/lib/types.ts, add filter state types:

    ```typescript
    export interface FilterState {
      dateRange: {
        start: string; // ISO date string
        end: string;   // ISO date string
      } | null;
      districts: number[]; // PPD district numbers (1-23)
      categories: ("Violent" | "Property" | "Other")[];
    }

    export interface FilterOptions {
      availableDistricts: number[];
      availableCategories: string[];
    }

    export interface CrimeIncident {
      dispatch_date: string;
      dispatch_time: string;
      district?: number;
      crime_category: string;
      text_general_code?: string;
      point?: { lat: number; lng: number };
    }
    ```

    2. Create web/src/lib/filters.ts with utilities:

    ```typescript
    import type { FilterState, CrimeIncident } from "./types";

    export function applyFilters<T extends CrimeIncident>(
      data: T[],
      filters: FilterState
    ): T[] {
      return data.filter((item) => {
        // Date filter
        if (filters.dateRange) {
          const itemDate = new Date(item.dispatch_date);
          const startDate = new Date(filters.dateRange.start);
          const endDate = new Date(filters.dateRange.end);
          if (itemDate < startDate || itemDate > endDate) {
            return false;
          }
        }

        // District filter
        if (filters.districts.length > 0 && item.district) {
          if (!filters.districts.includes(item.district)) {
            return false;
          }
        }

        // Category filter
        if (filters.categories.length > 0) {
          const itemCategory = normalizeCategory(item.crime_category);
          if (!filters.categories.includes(itemCategory)) {
            return false;
          }
        }

        return true;
      });
    }

    function normalizeCategory(category: string): "Violent" | "Property" | "Other" {
      const normalized = category.toLowerCase();
      if (normalized.includes("violent")) return "Violent";
      if (normalized.includes("property")) return "Property";
      return "Other";
    }

    export const PPD_DISTRICTS = Array.from({ length: 23 }, (_, i) => i + 1);
    export const CRIME_CATEGORIES = ["Violent", "Property", "Other"] as const;
    ```

    Rationale: Centralized filter logic ensures consistent behavior across components and enables type-safe filter operations.
  </action>
  <verify>
    grep -E "(FilterState|applyFilters)" /Users/dustinober/Projects/Philadelphia-Crime-Incidents-Analysis/web/src/lib/filters.ts
  </verify>
  <done>
    FilterState interface and applyFilters utility exist and compile without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Create useFilteredData hook</name>
  <files>web/src/hooks/useFilteredData.ts</files>
  <action>
    1. Create web/src/hooks/useFilteredData.ts:

    ```typescript
    "use client";

    import { useMemo } from "react";
    import useSWR from "swr";
    import { fetcher } from "@/lib/api";
    import type { FilterState, TrendRow } from "@/lib/types";
    import { applyFilters } from "@/lib/filters";

    export function useFilteredData(endpoint: string, filters: FilterState) {
      const { data, error, isLoading } = useSWR<TrendRow[]>(endpoint, fetcher);

      const filteredData = useMemo(() => {
        if (!data) return [];
        return applyFilters(data, filters);
      }, [data, filters]);

      return {
        data: filteredData,
        allData: data,
        isLoading,
        error,
        filteredCount: filteredData.length,
        totalCount: data?.length ?? 0,
      };
    }
    ```

    Rationale: Custom hook encapsulates SWR fetching with client-side filtering, providing a consistent interface for components.
  </action>
  <verify>
    grep -E "(useFilteredData|useSWR|applyFilters)" /Users/dustinober/Projects/Philadelphia-Crime-Incidents-Analysis/web/src/hooks/useFilteredData.ts
  </verify>
  <done>
    useFilteredData hook exists, uses SWR and applyFilters, and returns filtered/all data
  </done>
</task>

<task type="auto">
  <name>Create AdvancedFilters component</name>
  <files>web/src/components/filters/AdvancedFilters.tsx</files>
  <action>
    1. Create web/src/components/filters/AdvancedFilters.tsx:

    ```typescript
    "use client";

    import { useState } from "react";
    import { ChevronDown, ChevronUp, X } from "lucide-react";
    import type { FilterState } from "@/lib/types";
    import { PPD_DISTRICTS, CRIME_CATEGORIES } from "@/lib/filters";

    interface AdvancedFiltersProps {
      filters: FilterState;
      onChange: (filters: FilterState) => void;
      resultCount?: number;
      totalCount?: number;
    }

    export function AdvancedFilters({ filters, onChange, resultCount, totalCount }: AdvancedFiltersProps) {
      const [isExpanded, setIsExpanded] = useState(true);

      const setDateRange = (start: string, end: string) => {
        onChange({
          ...filters,
          dateRange: { start, end },
        });
      };

      const toggleDistrict = (district: number) => {
        const newDistricts = filters.districts.includes(district)
          ? filters.districts.filter((d) => d !== district)
          : [...filters.districts, district];
        onChange({ ...filters, districts: newDistricts });
      };

      const toggleCategory = (category: "Violent" | "Property" | "Other") => {
        const newCategories = filters.categories.includes(category)
          ? filters.categories.filter((c) => c !== category)
          : [...filters.categories, category];
        onChange({ ...filters, categories: newCategories });
      };

      const clearAll = () => {
        onChange({ dateRange: null, districts: [], categories: [] });
      };

      const hasActiveFilters =
        filters.dateRange !== null ||
        filters.districts.length > 0 ||
        filters.categories.length > 0;

      return (
        <div className="rounded-lg border border-slate-200 bg-white p-4">
          <div className="flex items-center justify-between">
            <h3 className="font-semibold text-slate-900">Filters</h3>
            <div className="flex items-center gap-2">
              {resultCount !== undefined && totalCount !== undefined && (
                <span className="text-sm text-slate-600">
                  {resultCount} of {totalCount} records
                </span>
              )}
              {hasActiveFilters && (
                <button
                  onClick={clearAll}
                  className="text-sm text-blue-700 hover:text-blue-900"
                >
                  Clear all
                </button>
              )}
              <button
                onClick={() => setIsExpanded(!isExpanded)}
                className="text-slate-500 hover:text-slate-700"
                aria-label={isExpanded ? "Collapse filters" : "Expand filters"}
              >
                {isExpanded ? <ChevronUp className="h-5 w-5" /> : <ChevronDown className="h-5 w-5" />}
              </button>
            </div>
          </div>

          {isExpanded && (
            <div className="mt-4 space-y-4">
              {/* Date Range */}
              <div>
                <label className="mb-2 block text-sm font-medium text-slate-700">
                  Date Range
                </label>
                <div className="flex gap-2">
                  <input
                    type="date"
                    value={filters.dateRange?.start ?? ""}
                    onChange={(e) =>
                      setDateRange(e.target.value, filters.dateRange?.end ?? "")
                    }
                    className="rounded-md border border-slate-300 px-3 py-2 text-sm"
                  />
                  <span className="self-center text-slate-500">to</span>
                  <input
                    type="date"
                    value={filters.dateRange?.end ?? ""}
                    onChange={(e) =>
                      setDateRange(filters.dateRange?.start ?? "", e.target.value)
                    }
                    className="rounded-md border border-slate-300 px-3 py-2 text-sm"
                  />
                </div>
              </div>

              {/* Districts */}
              <div>
                <label className="mb-2 block text-sm font-medium text-slate-700">
                  Police Districts
                </label>
                <div className="flex flex-wrap gap-2">
                  {PPD_DISTRICTS.map((district) => (
                    <button
                      key={district}
                      onClick={() => toggleDistrict(district)}
                      className={`rounded-md border px-3 py-1.5 text-sm transition-colors ${
                        filters.districts.includes(district)
                          ? "border-blue-500 bg-blue-50 text-blue-700"
                          : "border-slate-300 bg-white text-slate-700 hover:bg-slate-50"
                      }`}
                    >
                      D{district}
                    </button>
                  ))}
                </div>
              </div>

              {/* Categories */}
              <div>
                <label className="mb-2 block text-sm font-medium text-slate-700">
                  Crime Categories
                </label>
                <div className="flex flex-wrap gap-2">
                  {CRIME_CATEGORIES.map((category) => (
                    <button
                      key={category}
                      onClick={() => toggleCategory(category)}
                      className={`rounded-md border px-3 py-1.5 text-sm transition-colors ${
                        filters.categories.includes(category)
                          ? "border-blue-500 bg-blue-50 text-blue-700"
                          : "border-slate-300 bg-white text-slate-700 hover:bg-slate-50"
                      }`}
                    >
                      {category}
                    </button>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }
    ```

    Rationale: Unified filter component provides consistent UI for all filter types and visual feedback for active filters.
  </action>
  <verify>
    grep -E "(AdvancedFilters|toggleDistrict|toggleCategory)" /Users/dustinober/Projects/Philadelphia-Crime-Incidents-Analysis/web/src/components/filters/AdvancedFilters.tsx
  </verify>
  <done>
    AdvancedFilters component renders with date, district, and category controls
  </done>
</task>

</tasks>

<verification>
1. Check types compile: `cd web && npm run typecheck`
2. Verify filter utility exports: `grep -E "export.*applyFilters|export.*PPD_DISTRICTS" web/src/lib/filters.ts`
3. Verify hook exports useFilteredData: `grep "export.*useFilteredData" web/src/hooks/useFilteredData.ts`
4. Verify component exports AdvancedFilters: `grep "export.*AdvancedFilters" web/src/components/filters/AdvancedFilters.tsx`
</verification>

<success_criteria>
- FilterState type defines dateRange, districts, and categories
- applyFilters function filters data arrays by all three criteria
- useFilteredData hook combines SWR with applyFilters
- AdvancedFilters component provides UI for all three filter types
- All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-quality/03-02-SUMMARY.md` with:
- Filter type definitions created
- Filter utility functions implemented
- useFilteredData hook API surface
- AdvancedFilters component features
</output>
