---
phase: 05-dashboard-cross-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - dashboard/config.py
  - dashboard/components/state.py
  - dashboard/components/__init__.py
autonomous: true

must_haves:
  truths:
    - "Sidebar filters have separate pending state that doesn't trigger recomputation until apply button clicked"
    - "Apply button is disabled when no pending changes exist, enabled when changes are pending"
    - "Session state stores both pending and applied filter values separately"
    - "Filter state module provides clear API for checking pending status"
  artifacts:
    - path: "dashboard/components/state.py"
      provides: "Cross-filter state management (pending/applied separation)"
      exports: ["FilterState", "PendingFilters", "has_pending_changes", "get_applied_state"]
    - path: "dashboard/config.py"
      provides: "State management configuration"
      contains: "STATE_CONFIG"
  key_links:
    - from: "dashboard/app.py"
      to: "dashboard/components/state.py"
      via: "import FilterState, PendingFilters"
      pattern: "from dashboard.components.state import"
---

<objective>
Create state management infrastructure separating pending and applied filter states to support the apply button pattern for sidebar filters.

Purpose: Sidebar filters require explicit apply button (deliberate filtering) while view-to-view cross-filters are instant (exploratory). This requires separating pending changes from applied state.

Output: State management module with pending/applied separation, apply button tracking, and clean API for filter components.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-dashboard-cross-filtering/05-CONTEXT.md
@.planning/phases/05-dashboard-cross-filtering/05-RESEARCH.md

# Existing filter state patterns
@dashboard/filters/time_filters.py
@dashboard/filters/geo_filters.py
@dashboard/filters/crime_filters.py
@dashboard/config.py
</context>

<tasks>

<task type="auto">
  <name>Create state management module for cross-filtering</name>
  <files>dashboard/components/state.py</files>
  <action>
Create new file `dashboard/components/state.py` with state management infrastructure:

1. **PendingFilters NamedTuple**: Container for pending sidebar filter changes
   - Fields: `time_pending: bool`, `geo_pending: bool`, `crime_pending: bool`
   - Property: `has_any_pending: bool` returns True if any field is True

2. **FilterState NamedTuple**: Container for applied filter state (what's actually used for filtering)
   - Fields: `start_date: str`, `end_date: str`, `districts: list[int]`, `crime_categories: list[str]`, `crime_types: list[str] | None`
   - All fields represent the APPLIED state (after apply button click)

3. **State management functions**:
   - `initialize_filter_state()`: Initialize session state for pending and applied filters on first load
   - `mark_filter_pending(filter_type: str)`: Mark a specific filter type as having pending changes
   - `clear_pending_filters()`: Clear all pending flags (called after apply)
   - `has_pending_changes() -> bool`: Check if any filters have pending changes
   - `get_applied_state() -> FilterState`: Get current applied filter state
   - `update_applied_state(time_state, geo_state, crime_state)`: Update applied state from current pending values

4. **Session state keys** (use constants at module level):
   - PENDING_FILTERS_KEY = "pending_filters"
   - APPLIED_FILTERS_KEY = "applied_filters"
   - FILTER_INIT_KEY = "filter_state_initialized"

Implementation notes:
- Use `st.session_state` for all state storage
- Initialize state if keys don't exist (first page load)
- Follow existing NamedTuple pattern from time_filters.py and geo_filters.py
- Type hints using `| None` for optional fields (Python 3.10+ union syntax)

DO NOT:
- Modify existing filter modules (time_filters.py, geo_filters.py, crime_filters.py) - that happens in plan 02
- Create any UI components (apply button is plan 02)
- Implement view-to-view cross-filtering (plan 03)
  </action>
  <verify>
1. Check file exists: `test -f dashboard/components/state.py`
2. Verify exports: `python -c "from dashboard.components.state import PendingFilters, FilterState, has_pending_changes, get_applied_state; print('Exports OK')"`
3. Check type annotations: `grep -E "NamedTuple|class|def " dashboard/components/state.py | head -20`
  </verify>
  <done>
Module exports PendingFilters, FilterState, and all state management functions. Session state keys defined as constants. State initialization logic handles first page load.
  </done>
</task>

<task type="auto">
  <name>Add state configuration to dashboard config</name>
  <files>dashboard/config.py</files>
  <action>
Add state management configuration to `dashboard/config.py`:

1. Add `STATE_CONFIG` dict with:
   - `apply_button_enabled: bool = True` (master switch for apply button feature)
   - `auto_sync_url: bool = False` (sidebar filters only sync to URL on apply, not on change)
   - `pending_ttl: int = 300` (5 minutes - how long pending state persists)
   - `view_state_ttl: int = 1800` (30 minutes - view-to-view cross-filter state)

2. Update imports if needed (no new imports required for this config)

Place after CACHE_CONFIG, before DISPLAY_CONFIG section.

Configuration rationale:
- apply_button_enabled: Master switch to disable apply button pattern if needed
- auto_sync_url: False means sidebar filters only write to URL on apply (not on every change)
- pending_ttl: Pending state expires after 5 minutes of inactivity
- view_state_ttl: View selections (active_district, active_crime_type) persist longer
  </action>
  <verify>
1. Check config has STATE_CONFIG: `grep -A 10 "STATE_CONFIG" dashboard/config.py`
2. Verify all required keys present: `grep -E "apply_button_enabled|auto_sync_url|pending_ttl|view_state_ttl" dashboard/config.py`
  </verify>
  <done>
STATE_CONFIG dict added to dashboard/config.py with all 4 required keys and default values. Positioned after CACHE_CONFIG section.
  </done>
</task>

<task type="auto">
  <name>Update components package exports</name>
  <files>dashboard/components/__init__.py</files>
  <action>
Update `dashboard/components/__init__.py` to export state management types:

Add to __init__.py:
```python
from dashboard.components.state import (
    PendingFilters,
    FilterState,
    has_pending_changes,
    get_applied_state,
    initialize_filter_state,
    mark_filter_pending,
    clear_pending_filters,
    update_applied_state,
)
```

This allows other modules to import with:
```python
from dashboard.components import PendingFilters, FilterState
```

DO NOT:
- Export cache.py functions (already exported in Phase 4)
- Add any new functionality beyond state exports
  </action>
  <verify>
1. Check imports added: `grep "from dashboard.components.state import" dashboard/components/__init__.py`
2. Verify can import from package: `python -c "from dashboard.components import PendingFilters, FilterState; print('Package exports OK')"`
  </verify>
  <done>
dashboard/components/__init__.py exports all state management types and functions. Package-level imports work correctly.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
1. Module structure: State management module created with clean API
2. Type safety: NamedTuples used for immutable state containers
3. Session state: All state uses st.session_state with defined keys
4. Configuration: STATE_CONFIG added with all required settings
5. Package exports: Components package properly exports state types

Verification commands:
```bash
# Test module imports
python -c "
from dashboard.components.state import PendingFilters, FilterState, has_pending_changes, get_applied_state
from dashboard.components import PendingFilters, FilterState
from dashboard.config import STATE_CONFIG
print('All imports successful')
"

# Verify state config structure
python -c "
from dashboard.config import STATE_CONFIG
assert 'apply_button_enabled' in STATE_CONFIG
assert 'auto_sync_url' in STATE_CONFIG
assert 'pending_ttl' in STATE_CONFIG
assert 'view_state_ttl' in STATE_CONFIG
print('STATE_CONFIG has all required keys')
"
```
</verification>

<success_criteria>
1. State management module (state.py) created with 4+ functions and 2 NamedTuples
2. Session state initialization handles first page load correctly
3. Pending/applied state separation implemented with clear API
4. STATE_CONFIG added to dashboard config with all 4 keys
5. Components package exports state types for easy importing
6. No existing filter modules modified (separation of concerns)
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-cross-filtering/05-01-SUMMARY.md`
</output>
