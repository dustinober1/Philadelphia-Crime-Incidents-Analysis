---
phase: 05-dashboard-cross-filtering
plan: 03
type: execute
wave: 2
depends_on: [01, 02]
files_modified:
  - dashboard/components/plotly_interactions.py
  - dashboard/components/__init__.py
  - dashboard/config.py
autonomous: true

must_haves:
  truths:
    - "Plotly charts use on_select='rerun' to enable selection event handling"
    - "Selection events store active selections in session state for cross-filtering"
    - "Selection state includes: active_view, active_districts, active_crime_types, active_time_range"
    - "Session state keys are namespaced to avoid conflicts (view_selection_*)"
    - "Utility functions provide clean API for reading/writing selection state"
  artifacts:
    - path: "dashboard/components/plotly_interactions.py"
      provides: "Plotly selection event handling utilities"
      exports: ["register_plotly_selection", "get_selection_state", "clear_selection_state", "update_selection_from_event"]
    - path: "dashboard/config.py"
      provides: "Plotly interaction configuration"
      contains: "PLOTLY_CONFIG"
  key_links:
    - from: "dashboard/pages/overview.py"
      to: "dashboard/components/plotly_interactions.py"
      via: "import register_plotly_selection"
      pattern: "from dashboard.components.plotly_interactions import"
    - from: "dashboard/pages/spatial.py"
      to: "dashboard/components/plotly_interactions.py"
      via: "import register_plotly_selection"
      pattern: "from dashboard.components.plotly_interactions import"
---

<objective>
Create Plotly selection event handling infrastructure for view-to-view cross-filtering interactions.

Purpose: View-to-view cross-filters (clicking a district on spatial map to filter temporal view) require Plotly selection events and session state management for active selections.

Output: Selection event utilities, session state management for view selections, Plotly configuration.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-dashboard-cross-filtering/05-CONTEXT.md
@.planning/phases/05-dashboard-cross-filtering/05-RESEARCH.md

# State management from plans 01-02
@dashboard/components/state.py
@dashboard/config.py

# Existing page renderers (will be modified in plan 04)
@dashboard/pages/overview.py
@dashboard/pages/temporal.py
@dashboard/pages/spatial.py
@dashboard/pages/correlations.py
@dashboard/pages/advanced.py
</context>

<tasks>

<task type="auto">
  <name>Create Plotly selection event utilities module</name>
  <files>dashboard/components/plotly_interactions.py</files>
  <action>
Create new file `dashboard/components/plotly_interactions.py` with selection event handling:

1. **Session state keys** (module-level constants):
```python
# View selection state keys
VIEW_SELECTION_KEY = "view_selections"
ACTIVE_VIEW_KEY = "active_view"
ACTIVE_DISTRICTS_KEY = "active_districts"
ACTIVE_CRIME_TYPES_KEY = "active_crime_types"
ACTIVE_TIME_RANGE_KEY = "active_time_range"
```

2. **ViewSelectionState NamedTuple**:
```python
class ViewSelectionState(NamedTuple):
    """Container for current view-to-view selection state."""
    active_view: str | None  # Which view triggered selection (e.g., "spatial", "temporal")
    active_districts: list[int] | None  # Selected districts from spatial view
    active_crime_types: list[str] | None  # Selected crime types from overview/correlations
    active_time_range: tuple[str, str] | None  # Selected time range from temporal view
```

3. **Core utility functions**:

   `initialize_view_selection_state()`:
   - Initialize session state for view selections if not exists
   - Set default: ViewSelectionState(active_view=None, active_districts=None, active_crime_types=None, active_time_range=None)

   `register_plotly_selection(fig, key: str)`:
   - Configure Plotly figure for selection events
   - Set `fig.update_layout(dragmode='select')` for box/lasso select
   - Return figure with selection enabled
   - Key is used to identify which chart generated selection

   `update_selection_from_event(selection_event, source_view: str)`:
   - Parse selection event from st.plotly_chart on_select="rerun"
   - Extract selected points (districts, crime types, time ranges)
   - Update session state with new selection
   - Handle selection type based on source_view:
     - "spatial": Extract district IDs from point data
     - "overview": Extract crime categories/types
     - "temporal": Extract time range from x-axis

   `get_selection_state() -> ViewSelectionState`:
   - Return current view selection state from session state
   - Return empty state if not initialized

   `clear_selection_state()`:
   - Reset all view selections to None
   - Called when user clicks in sidebar or changes tab

   `has_active_selection() -> bool`:
   - Return True if any view selection is active

   `get_active_filter_kwargs() -> dict`:
   - Convert selection state to filter kwargs for apply_filters()
   - Returns: {"districts": [...], "crime_types": [...], "start_date": ..., "end_date": ...}
   - Only includes non-None selections

4. **Selection parsing helpers** (private functions):

   `_extract_districts_from_selection(selection_points) -> list[int]`:
   - Parse district IDs from selected plot points
   - Handle point data from spatial charts (dc_dist field)

   `_extract_crime_types_from_selection(selection_points) -> list[str]`:
   - Parse crime types from selected points
   - Handle text_general or crime_category field

   `_extract_time_range_from_selection(selection_points) -> tuple[str, str]`:
   - Parse min/max time from selected points
   - Returns (start_date, end_date) strings

Implementation notes:
- Selection events come from `st.session_state[key]['selection']['points']`
- Each point has customdata or axis values depending on chart type
- Use try/except for robust parsing (selection may be malformed)
- Filter selections must align with sidebar filter types (districts=int, crime_types=str, dates=str)

DO NOT:
- Modify page renderers (plan 04)
- Implement opacity/dimming logic (plan 04)
- Create UI components for clearing selections
  </action>
  <verify>
1. Check file exists: `test -f dashboard/components/plotly_interactions.py`
2. Verify exports: `python -c "from dashboard.components.plotly_interactions import register_plotly_selection, get_selection_state, clear_selection_state; print('Exports OK')"`
3. Check session state keys: `grep "KEY.*=" dashboard/components/plotly_interactions.py | grep -v "^#"`
4. Verify ViewSelectionState: `grep "class ViewSelectionState" dashboard/components/plotly_interactions.py`
  </verify>
  <done>
Module exports ViewSelectionState NamedTuple and all utility functions. Session state keys defined as constants. Selection parsing handles district/crime_type/time_range extractions.
  </done>
</task>

<task type="auto">
  <name>Add Plotly configuration to dashboard config</name>
  <files>dashboard/config.py</files>
  <action>
Add Plotly interaction configuration to `dashboard/config.py`:

1. Add `PLOTLY_CONFIG` dict with:
```python
PLOTLY_CONFIG = {
    # Selection mode for charts
    "selection_mode": "select",  # "select" for box/lasso, False to disable
    # Selection event handling
    "on_select_rerun": True,  # Use on_select="rerun" for instant cross-filtering
    # Visual feedback for selections
    "selected_opacity": 1.0,  # Full opacity for selected elements
    "unselected_opacity": 0.3,  # 30% opacity for unselected (dimmed)
    # Hover behavior
    "hover_mode": "closest",  # Show hover info for nearest data point
    # Selection persistence
    "selection_ttl": 1800,  # 30 minutes - view selections persist longer than pending filters
    # Selection limits
    "max_selections": 100,  # Max points allowed in selection (prevents performance issues)
}
```

2. Add import if needed (no new imports for config dict)

Place after STATE_CONFIG, before DISPLAY_CONFIG section.

Configuration rationale:
- selection_mode: "select" enables box/lasso select on all Plotly charts
- on_select_rerun: True means selections trigger instant rerun (exploratory interaction)
- opacities: 1.0 for selected, 0.3 for dimmed (30% visibility of filtered-out data)
- selection_ttl: View selections persist 30 minutes (longer than 5-min pending filter state)
- max_selections: Prevents selecting too many points which would slow down filtering
  </action>
  <verify>
1. Check config has PLOTLY_CONFIG: `grep -A 15 "PLOTLY_CONFIG" dashboard/config.py`
2. Verify all required keys: `grep -E "selection_mode|on_select_rerun|selected_opacity|unselected_opacity|hover_mode|selection_ttl|max_selections" dashboard/config.py`
  </verify>
  <done>
PLOTLY_CONFIG added to dashboard/config.py with all 7 required keys and default values. Positioned after STATE_CONFIG section.
  </done>
</task>

<task type="auto">
  <name>Update components package exports for plotly interactions</name>
  <files>dashboard/components/__init__.py</files>
  <action>
Update `dashboard/components/__init__.py` to export plotly interaction utilities:

Add to __init__.py (after existing state exports):
```python
from dashboard.components.plotly_interactions import (
    ViewSelectionState,
    register_plotly_selection,
    get_selection_state,
    clear_selection_state,
    update_selection_from_event,
    has_active_selection,
    get_active_filter_kwargs,
)
```

This allows page renderers to import with:
```python
from dashboard.components import ViewSelectionState, register_plotly_selection
```

DO NOT:
- Remove existing exports (cache, state)
- Add any new functionality beyond plotly interaction exports
  </action>
  <verify>
1. Check imports added: `grep "from dashboard.components.plotly_interactions import" dashboard/components/__init__.py`
2. Verify can import from package: `python -c "from dashboard.components import ViewSelectionState, register_plotly_selection; print('Package exports OK')"`
  </verify>
  <done>
dashboard/components/__init__.py exports all plotly interaction types and functions. Package-level imports work correctly.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
1. Plotly interaction module created with selection event handling
2. ViewSelectionState NamedTuple stores active selections (view, districts, crime types, time range)
3. Utility functions provide clean API for reading/writing selection state
4. Session state keys namespaced (view_selection_*) to avoid conflicts
5. PLOTLY_CONFIG added with all required configuration
6. Components package exports plotly interaction utilities

Verification commands:
```bash
# Test module imports
python -c "
from dashboard.components.plotly_interactions import (
    ViewSelectionState,
    register_plotly_selection,
    get_selection_state,
    clear_selection_state,
    has_active_selection,
    get_active_filter_kwargs,
)
from dashboard.components import ViewSelectionState, register_plotly_selection
from dashboard.config import PLOTLY_CONFIG
print('All imports successful')
"

# Verify plotly config structure
python -c "
from dashboard.config import PLOTLY_CONFIG
assert 'selection_mode' in PLOTLY_CONFIG
assert 'on_select_rerun' in PLOTLY_CONFIG
assert 'selected_opacity' in PLOTLY_CONFIG
assert 'unselected_opacity' in PLOTLY_CONFIG
assert 'selection_ttl' in PLOTLY_CONFIG
assert 'max_selections' in PLOTLY_CONFIG
print('PLOTLY_CONFIG has all required keys')
"
```
</verification>

<success_criteria>
1. Plotly interaction module (plotly_interactions.py) created with 6+ functions and 1 NamedTuple
2. ViewSelectionState stores active selections (active_view, districts, crime_types, time_range)
3. Selection parsing helpers extract data from Plotly selection events
4. get_active_filter_kwargs() converts selections to filter kwargs
5. PLOTLY_CONFIG added with all 7 keys (selection_mode, opacities, ttl, limits)
6. Components package exports plotly interaction utilities
7. No page renderers modified yet (separation of concerns)
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-cross-filtering/05-03-SUMMARY.md`
</output>
