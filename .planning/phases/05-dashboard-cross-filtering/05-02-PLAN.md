---
phase: 05-dashboard-cross-filtering
plan: 02
type: execute
wave: 1
depends_on: [01]
files_modified:
  - dashboard/filters/time_filters.py
  - dashboard/filters/geo_filters.py
  - dashboard/filters/crime_filters.py
  - dashboard/app.py
autonomous: true

must_haves:
  truths:
    - "Sidebar filters write pending state on change but do not trigger data reload"
    - "Apply button appears in sidebar and is disabled when no pending changes"
    - "Clicking apply button syncs pending state to applied state and triggers data reload"
    - "URL parameters update only when apply button is clicked (not on filter change)"
    - "Visual indicators (dot/icon) show which filters have pending changes"
  artifacts:
    - path: "dashboard/filters/time_filters.py"
      provides: "Time filter with pending state tracking"
      exports: ["render_time_filters_with_pending"]
    - path: "dashboard/filters/geo_filters.py"
      provides: "Geo filter with pending state tracking"
      exports: ["render_geo_filters_with_pending"]
    - path: "dashboard/filters/crime_filters.py"
      provides: "Crime filter with pending state tracking"
      exports: ["render_crime_filters_with_pending"]
    - path: "dashboard/app.py"
      provides: "Apply button integration and sidebar layout"
      contains: "apply_button rendering"
  key_links:
    - from: "dashboard/filters/time_filters.py"
      to: "dashboard/components/state.py"
      via: "import mark_filter_pending, has_pending_changes"
      pattern: "from dashboard.components.state import"
    - from: "dashboard/app.py"
      to: "dashboard/filters/*.py"
      via: "call render_*_filters_with_pending"
      pattern: "render_\w+_filters_with_pending"
---

<objective>
Integrate apply button pattern into sidebar filters, separating pending changes from applied state with visual feedback.

Purpose: Sidebar filters are deliberate selections (user knows what they want) and should require explicit apply to avoid unnecessary recomputations during multi-step filter configuration.

Output: Updated filter modules with pending state tracking, apply button in sidebar, visual indicators for pending changes.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-dashboard-cross-filtering/05-CONTEXT.md
@.planning/phases/05-dashboard-cross-filtering/05-RESEARCH.md
@.planning/phases/04-dashboard-foundation/04-06-SUMMARY.md

# State management from plan 01
@dashboard/components/state.py
@dashboard/config.py

# Existing filter modules to modify
@dashboard/filters/time_filters.py
@dashboard/filters/geo_filters.py
@dashboard/filters/crime_filters.py
@dashboard/app.py
</context>

<tasks>

<task type="auto">
  <name>Add pending state tracking to time filters</name>
  <files>dashboard/filters/time_filters.py</files>
  <action>
Modify `dashboard/filters/time_filters.py` to support pending state:

1. Add imports at top:
```python
from dashboard.components.state import mark_filter_pending, has_pending_changes, PendingFilters
```

2. Create new function `render_time_filters_with_pending(df, key_prefix="time")`:
   - Copy existing `render_time_filters()` logic
   - Add `on_change` callbacks to all widgets (selectbox, slider, multiselect, button)
   - Each callback calls `mark_filter_pending("time")`
   - Store filter state in session state WITHOUT triggering URL sync

3. Add visual indicator for pending state:
   - Before each widget, check `has_pending_changes()` and `time_pending` flag
   - Show dot indicator (ðŸ”µ) next to widget label if pending

4. Remove URL sync from this function (moved to apply button in app.py):
   - Remove `sync_time_filters_to_url()` call
   - Remove `read_time_filters_from_url()` call (app.py handles on load)

5. Keep `TimeFilterState` NamedTuple and helper functions unchanged

Callback pattern example:
```python
def _on_time_change():
    mark_filter_pending("time")

# In widget:
preset = st.selectbox(..., key=f"{key_prefix}_preset", on_change=_on_time_change)
```

DO NOT:
- Modify existing `render_time_filters()` function (create new function)
- Change `TimeFilterState` structure or helper functions
- Implement URL sync (app.py handles this)
  </action>
  <verify>
1. Check new function exists: `grep "render_time_filters_with_pending" dashboard/filters/time_filters.py`
2. Verify callbacks registered: `grep -c "on_change" dashboard/filters/time_filters.py`
3. Check imports added: `grep "from dashboard.components.state import" dashboard/filters/time_filters.py`
4. Verify visual indicator logic: `grep "pending.*ðŸ”µ\|has_pending_changes" dashboard/filters/time_filters.py`
  </verify>
  <done>
render_time_filters_with_pending() function created. All widgets have on_change callbacks calling mark_filter_pending(). Visual indicators (ðŸ”µ) show pending state. No URL sync in this function.
  </done>
</task>

<task type="auto">
  <name>Add pending state tracking to geo filters</name>
  <files>dashboard/filters/geo_filters.py</files>
  <action>
Modify `dashboard/filters/geo_filters.py` to support pending state:

1. Add imports at top:
```python
from dashboard.components.state import mark_filter_pending, has_pending_changes
```

2. Create new function `render_geo_filters_with_pending(df, key_prefix="geo")`:
   - Copy existing `render_geo_filters()` logic
   - Add `on_change` callbacks to checkbox and multiselect
   - Callbacks call `mark_filter_pending("geo")`
   - Store state in session state WITHOUT URL sync

3. Add visual indicator for pending state:
   - Show ðŸ”µ next to "Geographic Area" subheader if geo pending

4. Remove URL sync from this function:
   - Remove `sync_geo_filters_to_url()` call
   - Remove `read_geo_filters_from_url()` call

5. Keep `GeoFilterState` and helper functions unchanged

Callback pattern:
```python
def _on_geo_change():
    mark_filter_pending("geo")

select_all = st.checkbox(..., on_change=_on_geo_change)
```

DO NOT:
- Modify existing `render_geo_filters()` function
- Change `GeoFilterState` structure
- Implement URL sync
  </action>
  <verify>
1. Check new function exists: `grep "render_geo_filters_with_pending" dashboard/filters/geo_filters.py`
2. Verify callbacks: `grep -c "on_change" dashboard/filters/geo_filters.py`
3. Check imports: `grep "from dashboard.components.state import" dashboard/filters/geo_filters.py`
4. Verify pending indicator: `grep "ðŸ”µ\|geo_pending" dashboard/filters/geo_filters.py`
  </verify>
  <done>
render_geo_filters_with_pending() function created with on_change callbacks. Visual indicator (ðŸ”µ) shows pending geo changes. No URL sync in function.
  </done>
</task>

<task type="auto">
  <name>Add pending state tracking to crime filters</name>
  <files>dashboard/filters/crime_filters.py</files>
  <action>
Modify `dashboard/filters/crime_filters.py` to support pending state:

1. Add imports:
```python
from dashboard.components.state import mark_filter_pending, has_pending_changes
```

2. Create new function `render_crime_filters_with_pending(df, key_prefix="crime")`:
   - Copy existing `render_crime_filters()` logic
   - Add `on_change` callbacks to all widgets
   - Callbacks call `mark_filter_pending("crime")`
   - Store state WITHOUT URL sync

3. Add visual indicator for pending state:
   - Show ðŸ”µ next to "Crime Types" subheader if crime pending

4. Remove URL sync from this function

5. Keep `CrimeFilterState` and helper functions unchanged

DO NOT:
- Modify existing `render_crime_filters()` function
- Change `CrimeFilterState` structure
- Implement URL sync
  </action>
  <verify>
1. Check new function exists: `grep "render_crime_filters_with_pending" dashboard/filters/crime_filters.py`
2. Verify callbacks: `grep -c "on_change" dashboard/filters/crime_filters.py`
3. Check imports: `grep "from dashboard.components.state import" dashboard/filters/crime_filters.py`
4. Verify pending indicator: `grep "ðŸ”µ\|crime_pending" dashboard/filters/crime_filters.py`
  </verify>
  <done>
render_crime_filters_with_pending() function created with on_change callbacks. Visual indicator (ðŸ”µ) shows pending crime changes. No URL sync in function.
  </done>
</task>

<task type="auto">
  <name>Integrate apply button in app.py sidebar</name>
  <files>dashboard/app.py</files>
  <action>
Modify `dashboard/app.py` to integrate apply button:

1. Add imports:
```python
from dashboard.components.state import (
    has_pending_changes,
    clear_pending_filters,
    update_applied_state,
    get_applied_state,
    initialize_filter_state,
)
from dashboard.filters.time_filters import render_time_filters_with_pending, get_filter_dates
from dashboard.filters.geo_filters import render_geo_filters_with_pending, get_filter_districts
from dashboard.filters.crime_filters import render_crime_filters_with_pending, get_filter_categories, get_filter_crime_types
```

2. Initialize state at start of main():
```python
def main():
    _load_custom_css()
    initialize_filter_state()  # Add this line
    # ... rest of function
```

3. Replace filter rendering calls in sidebar:
   - `render_time_filters()` â†’ `render_time_filters_with_pending()`
   - `render_geo_filters()` â†’ `render_geo_filters_with_pending()`
   - `render_crime_filters()` â†’ `render_crime_filters_with_pending()`

4. Add apply button after crime filters (before st.markdown("---")):
```python
st.markdown("---")

# Apply button
if has_pending_changes():
    if st.button(":white_check_mark: Apply Filters", type="primary", use_container_width=True):
        # Update applied state from current filter values
        update_applied_state(time_state, geo_state, crime_state)
        # Clear pending flags
        clear_pending_filters()
        # Sync to URL
        _sync_all_filters_to_url(time_state, geo_state, crime_state)
        # Rerun to update views
        st.rerun()
else:
    st.button(":white_check_mark: Apply Filters", disabled=True, use_container_width=True)
```

5. Add helper function `_sync_all_filters_to_url()`:
```python
def _sync_all_filters_to_url(time_state, geo_state, crime_state):
    """Sync all applied filter states to URL parameters."""
    params = st.query_params
    # Time filters
    from dashboard.filters.time_filters import sync_time_filters_to_url
    sync_time_filters_to_url(time_state)
    # Geo filters
    from dashboard.filters.geo_filters import sync_geo_filters_to_url
    sync_geo_filters_to_url(geo_state)
    # Crime filters
    from dashboard.filters.crime_filters import sync_crime_filters_to_url
    sync_crime_filters_to_url(crime_state)
```

6. Update filter application logic to use applied state:
   - Change `filtered_df = apply_filters(...)` to use values from `get_applied_state()`
   - Or keep current logic since state updates on apply and rerun

DO NOT:
- Remove existing filter functions (render_time_filters, etc.) - they may be used elsewhere
- Change the visual layout beyond adding apply button
- Modify apply button behavior (disabled when no pending, enabled when pending)
  </action>
  <verify>
1. Check imports added: `grep "from dashboard.components.state import" dashboard/app.py`
2. Check new render functions called: `grep "render_\w+_filters_with_pending" dashboard/app.py`
3. Verify apply button logic: `grep -A 10 "Apply Filters" dashboard/app.py | grep "has_pending_changes\|st.rerun"`
4. Check sync function: `grep "_sync_all_filters_to_url" dashboard/app.py`
  </verify>
  <done>
Apply button integrated in sidebar. Button disabled when no pending changes, enabled when changes pending. On click: updates applied state, clears pending flags, syncs to URL, triggers rerun. All filter rendering uses pending-state-aware functions.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
1. All three filter modules have pending-state-aware rendering functions
2. Apply button appears in sidebar with correct enable/disable behavior
3. Visual indicators (ðŸ”µ) show which filters have pending changes
4. URL sync only happens on apply button click, not on filter change
5. Applied state updates correctly when apply button clicked

Verification commands:
```bash
# Verify all new functions exist
grep -l "render_\w+_filters_with_pending" dashboard/filters/*.py

# Check callbacks registered in each filter
for f in dashboard/filters/time_filters.py dashboard/filters/geo_filters.py dashboard/filters/crime_filters.py; do
    echo "$f: $(grep -c 'on_change' $f) callbacks"
done

# Verify apply button integration
grep -A 15 "Apply Filters" dashboard/app.py | grep -E "has_pending_changes|st.rerun|update_applied_state"
```
</verification>

<success_criteria>
1. All filter modules have pending-state rendering functions (time, geo, crime)
2. Each filter module has 2+ on_change callbacks marking pending state
3. Visual indicators (ðŸ”µ) appear next to filters with pending changes
4. Apply button integrates in app.py sidebar with correct enable/disable logic
5. URL sync happens only on apply (verified by checking sync calls)
6. Applied state updates correctly and views refresh on apply
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-cross-filtering/05-02-SUMMARY.md`
</output>
