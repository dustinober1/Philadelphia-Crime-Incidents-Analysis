---
phase: 05-dashboard-cross-filtering
plan: 05
type: execute
wave: 3
depends_on: [01, 02, 03, 04]
files_modified:
  - dashboard/app.py
  - dashboard/components/url_sync.py
  - dashboard/components/__init__.py
autonomous: false

must_haves:
  truths:
    - "View-to-view selections encoded in URL parameters (e.g., active_view=spatial&active_districts=22)"
    - "URL parameters omit when 'all selected' for clean URLs (e.g., no districts param when all districts active)"
    - "Sidebar filters and view selections share same URL namespace"
    - "Shareable URLs capture both sidebar filters and active view selections"
    - "Changing tabs or clicking in sidebar clears view selections (ephemeral state)"
  artifacts:
    - path: "dashboard/components/url_sync.py"
      provides: "URL encoding/decoding for view-to-view selections"
      exports: ["sync_view_selection_to_url", "read_view_selection_from_url", "clear_view_selection_from_url"]
    - path: "dashboard/app.py"
      provides: "Unified URL state sync for sidebar + view selections"
      contains: "URL sync orchestration"
  key_links:
    - from: "dashboard/components/plotly_interactions.py"
      to: "dashboard/components/url_sync.py"
      via: "import sync_view_selection_to_url"
      pattern: "from dashboard.components.url_sync import"
    - from: "dashboard/app.py"
      to: "dashboard/components/url_sync.py"
      via: "import sync_view_selection_to_url, read_view_selection_from_url"
      pattern: "from dashboard.components.url_sync import"
---

<objective>
Implement unified URL state encoding for both sidebar filters and view-to-view selections, enabling shareable dashboard views.

Purpose: Users can share URLs that capture complete dashboard state (sidebar filters + active view selections), with clean URLs that omit parameters when everything is selected.

Output: URL sync utilities integrated with app.py, view selections encoded in URL, shareable URLs work correctly.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-dashboard-cross-filtering/05-CONTEXT.md
@.planning/phases/05-dashboard-cross-filtering/05-RESEARCH.md
@.planning/phases/04-dashboard-foundation/04-06-SUMMARY.md

# State management and plotly interactions from plans 01-04
@dashboard/components/state.py
@dashboard/components/plotly_interactions.py
@dashboard/config.py
@dashboard/app.py

# Existing URL sync patterns (sidebar filters)
@dashboard/filters/time_filters.py
@dashboard/filters/geo_filters.py
@dashboard/filters/crime_filters.py
</context>

<tasks>

<task type="auto">
  <name>Create URL sync utilities for view selections</name>
  <files>dashboard/components/url_sync.py</files>
  <action>
Create new file `dashboard/components/url_sync.py` with URL encoding/decoding for view selections:

1. **URL parameter keys** (module-level constants):
```python
# View selection URL parameters
ACTIVE_VIEW_PARAM = "av"  # Short for "active_view"
ACTIVE_DISTRICTS_PARAM = "ad"  # Short for "active_districts"
ACTIVE_CRIME_TYPES_PARAM = "act"  # Short for "active_crime_types"
ACTIVE_TIME_RANGE_PARAM = "atr"  # Short for "active_time_range"
```

2. **Core utility functions**:

   `read_view_selection_from_url() -> dict`:
   - Read view selection parameters from st.query_params
   - Parse and validate each parameter
   - Return dict with: {active_view, active_districts, active_crime_types, active_time_range}
   - Handle missing/invalid parameters (return None)
   - Parse comma-separated lists (districts, crime_types)
   - Parse time range as "start_date,end_date"

   `sync_view_selection_to_url(selection_state: ViewSelectionState)`:
   - Encode view selection state to URL parameters
   - Use short parameter keys (av, ad, act, atr) for clean URLs
   - **Clean URL heuristic**: Omit parameter when value is None or represents "all selected"
   - Examples:
     - active_districts=None: Don't encode (all districts)
     - active_districts=[1,2,3]: Encode as "ad=1,2,3"
     - active_view=None: Don't encode (no active selection)
   - Use st.query_params to write to URL

   `clear_view_selection_from_url()`:
   - Remove all view selection parameters from URL
   - Delete av, ad, act, atr params if present
   - Called when user clears selection or changes sidebar filters

   `format_selection_for_url(value) -> str | None`:
   - Format value for URL encoding
   - Lists: Join with commas
   - Tuples: Join with commas
   - None: Return None (parameter omitted)
   - Strings/ints: Return str(value)

   `parse_selection_from_url(param_value: str, value_type: type)`:
   - Parse URL parameter value to correct type
   - value_type=list[int]: Parse comma-separated ints
   - value_type=list[str]: Parse comma-separated strings
   - value_type=tuple[str, str]: Parse "start,end" tuple
   - Return None if parsing fails

3. **URL parameter validation**:

   `_validate_districts(districts_str: str) -> list[int] | None`:
   - Parse comma-separated district IDs
   - Validate each is int and in valid range (1-25)
   - Return None if invalid

   `_validate_crime_types(crime_types_str: str) -> list[str] | None`:
   - Parse comma-separated crime types
   - Validate against known crime types (optional, can be lenient)
   - Return None if empty

   `_validate_time_range(time_range_str: str) -> tuple[str, str] | None`:
   - Parse "YYYY-MM-DD,YYYY-MM-DD" format
   - Validate date format and logical range (start <= end)
   - Return None if invalid

Implementation notes:
- URL params use short keys for cleaner URLs (av vs active_view)
- Clean URL heuristic: Don't encode "all selected" or None values
- View selections are ephemeral: Cleared when sidebar filters change
- URL namespace is unified: Sidebar params (start_date, districts, crime_types) + view params (av, ad, act, atr)

DO NOT:
- Modify sidebar filter URL sync (already working)
- Handle URL encoding/decoding errors beyond basic validation
- Create any UI components (this is pure URL logic)
  </action>
  <verify>
1. Check file exists: `test -f dashboard/components/url_sync.py`
2. Verify exports: `python -c "from dashboard.components.url_sync import sync_view_selection_to_url, read_view_selection_from_url, clear_view_selection_from_url; print('Exports OK')"`
3. Check URL parameter constants: `grep "_PARAM.*=" dashboard/components/url_sync.py | grep -v "^#"`
4. Verify parsing logic: `grep -c "parse.*from_url\|validate" dashboard/components/url_sync.py`
  </verify>
  <done>
Module exports URL sync functions for view selections. URL parameter keys defined as constants. Clean URL heuristic omits params for None/all-selected values. Parsing validation handles districts/crime_types/time_range.
  </done>
</task>

<task type="auto">
  <name>Update components package exports for URL sync</name>
  <files>dashboard/components/__init__.py</files>
  <action>
Update `dashboard/components/__init__.py` to export URL sync utilities:

Add to __init__.py (after plotly interaction exports):
```python
from dashboard.components.url_sync import (
    sync_view_selection_to_url,
    read_view_selection_from_url,
    clear_view_selection_from_url,
)
```

This allows other modules to import with:
```python
from dashboard.components import sync_view_selection_to_url
```

DO NOT:
- Remove existing exports (cache, state, plotly_interactions)
- Add any new functionality beyond URL sync exports
  </action>
  <verify>
1. Check imports added: `grep "from dashboard.components.url_sync import" dashboard/components/__init__.py`
2. Verify can import from package: `python -c "from dashboard.components import sync_view_selection_to_url; print('Package exports OK')"`
  </verify>
  <done>
dashboard/components/__init__.py exports all URL sync functions. Package-level imports work correctly.
  </done>
</task>

<task type="auto">
  <name>Integrate URL sync for view selections in app.py</name>
  <files>dashboard/app.py</files>
  <action>
Modify `dashboard/app.py` to integrate URL sync for view selections:

1. Add imports:
```python
from dashboard.components import (
    sync_view_selection_to_url,
    read_view_selection_from_url,
    clear_view_selection_from_url,
)
from dashboard.components.plotly_interactions import ViewSelectionState, initialize_view_selection_state
```

2. Initialize view selection state at start of main():
```python
def main():
    _load_custom_css()

    # Initialize state
    initialize_filter_state()
    initialize_view_selection_state()  # Add this line

    # Load view selections from URL
    url_view_selection = read_view_selection_from_url()
    if url_view_selection.get("active_view"):
        # Restore view selection from URL
        from dashboard.components.plotly_interactions import update_selection_state_from_dict
        update_selection_state_from_dict(url_view_selection)
```

3. Add helper function to update selection state from URL dict:
```python
def _update_selection_state_from_dict(selection_dict: dict):
    """Update view selection state from URL parameters dict."""
    from dashboard.components.plotly_interactions import ViewSelectionState
    import streamlit as st

    selection_state = ViewSelectionState(
        active_view=selection_dict.get("active_view"),
        active_districts=selection_dict.get("active_districts"),
        active_crime_types=selection_dict.get("active_crime_types"),
        active_time_range=selection_dict.get("active_time_range"),
    )
    st.session_state["view_selections"] = selection_state
```

4. Sync view selections to URL after tab rendering:
```python
    # After rendering tabs, sync current view selection to URL
    current_selection = get_selection_state()
    if current_selection.active_view:
        sync_view_selection_to_url(current_selection)
```

5. Clear view selections when sidebar filters change:
```python
    # In apply button click handler (from plan 02):
    if st.button(":white_check_mark: Apply Filters", ...):
        update_applied_state(time_state, geo_state, crime_state)
        clear_pending_filters()
        clear_view_selection_from_url()  # Add this line
        _sync_all_filters_to_url(time_state, geo_state, crime_state)
        st.rerun()
```

6. Clear view selections when tab changes:
```python
    # Track active tab in session state
    if "active_tab" not in st.session_state:
        st.session_state["active_tab"] = 0

    # Detect tab change
    current_tab = st.tabs(list(PAGE_NAMES.values()))
    if st.session_state["active_tab"] != current_tab:
        # Tab changed, clear view selections
        clear_view_selection_from_url()
        st.session_state["active_tab"] = current_tab
        st.rerun()
```

DO NOT:
- Remove existing sidebar filter URL sync
- Break apply button logic from plan 02
- Change tab rendering (only add selection clearing)
  </action>
  <verify>
1. Check imports added: `grep "from dashboard.components import" dashboard/app.py | grep -E "sync_view_selection_to_url|clear_view_selection_from_url"`
2. Verify URL sync on apply: `grep "clear_view_selection_from_url" dashboard/app.py`
3. Check tab change detection: `grep "active_tab\|Tab changed" dashboard/app.py`
4. Verify selection sync after tabs: `grep "sync_view_selection_to_url\|current_selection" dashboard/app.py`
  </verify>
  <done>
View selections read from URL on page load. Selections sync to URL after tab rendering. Apply button clears view selections (sidebar overrides view). Tab changes clear view selections. URL captures full dashboard state.
  </done>
</task>

<task type="checkpoint:human-verify">
  <what-built>Complete cross-filtering implementation with URL state sync</what-built>
  <how-to-verify>
1. Start dashboard: `streamlit run dashboard/app.py`
2. Test sidebar filters:
   - Change time range, verify apply button enables
   - Click apply, verify URL updates (e.g., ?start_date=2020-01-01&end_date=2022-12-31)
   - Verify views update to filtered data
3. Test view-to-view cross-filtering:
   - Go to Spatial tab, click on District 22 bar
   - Switch to Temporal tab, verify only District 22 data shown
   - Verify URL has view params (e.g., ?av=spatial&ad=22)
   - Verify filtered-out districts dimmed (30% opacity)
4. Test shareable URLs:
   - Copy URL with filters + selections
   - Open in new browser/incognito window
   - Verify same filters and selections active
5. Test selection clearing:
   - Make view selection, verify active
   - Change sidebar filter and click apply
   - Verify view selection cleared
   - Switch tabs, verify selection cleared
6. Test clean URLs:
   - Select all districts, verify "districts" param omitted from URL
   - Clear view selection, verify view params (av, ad, act, atr) omitted
7. Verify performance:
   - All interactions should complete in <3 seconds
   - Apply button should trigger fast rerun
   - View selections should be instant
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
Overall phase checks:
1. URL sync module created with encoding/decoding for view selections
2. View selections read from URL on page load
3. View selections sync to URL after interactions
4. Clean URL heuristic omits params for None/all-selected values
5. Apply button clears view selections (sidebar overrides view)
6. Tab changes clear view selections
7. Shareable URLs capture both sidebar filters and view selections
8. URL namespace is unified (sidebar + view params coexist)

Verification commands:
```bash
# Test module imports
python -c "
from dashboard.components.url_sync import (
    sync_view_selection_to_url,
    read_view_selection_from_url,
    clear_view_selection_from_url,
)
from dashboard.components import sync_view_selection_to_url
print('All imports successful')
"

# Verify URL parameter constants
grep "_PARAM.*=" dashboard/components/url_sync.py | grep -v "^#"

# Check URL sync integration in app.py
grep -E "sync_view_selection_to_url|read_view_selection_from_url|clear_view_selection_from_url" dashboard/app.py
```
</verification>

<success_criteria>
1. URL sync module (url_sync.py) created with 3+ functions and 4 URL parameter constants
2. read_view_selection_from_url() parses av, ad, act, atr params from URL
3. sync_view_selection_to_url() encodes selections with clean URL heuristic (omit None/all)
4. clear_view_selection_from_url() removes view params from URL
5. View selections load from URL on page load (app.py integration)
6. View selections sync to URL after tab rendering
7. Apply button clears view selections (sidebar has priority)
8. Tab changes clear view selections (ephemeral state)
9. Shareable URLs work: Opening URL in new session restores full state
10. Clean URLs: "All selected" selections omit parameters
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-cross-filtering/05-05-SUMMARY.md`
</output>
