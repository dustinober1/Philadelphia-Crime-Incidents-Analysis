---
phase: 14-repository-cleanup
plan: 06
type: execute
wave: 3
depends_on: [14-02, 14-03, 14-04, 14-05]
files_modified: [.gitignore, Makefile]
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Safety gate git status command validates workspace is clean"
    - "Safety gate test validation commands verify functionality"
    - "Safety gates documented and ready for use"
    - "Gitignore excludes temporary files from future commits"
  artifacts:
    - path: ".planning/phases/14-repository-cleanup/safety-gates.md"
      provides: "Safety gate documentation for cleanup operations"
      contains: "git status|pytest|git diff"
    - path: ".gitignore"
      provides: "Git ignore patterns for temporary files"
      contains: "*.pyc|__pycache__|.DS_Store|*.swp|*.coverage"
    - path: "Makefile"
      provides: "Make targets for cleanup operations"
      contains: "clean|cleanup|pyclean"
  key_links:
    - from: "safety-gates.md"
      to: "Git/pytest commands"
      via: "Documented validation procedures"
      pattern: "git status.*pytest"
    - from: "Makefile"
      to: "Workspace"
      via: "make clean target"
      pattern: "clean"
---

<objective>
Implement safety gates for cleanup operations and update .gitignore.

Purpose: Prevent accidental removal of active code by creating validated cleanup commands. Add comprehensive .gitignore patterns to prevent future accumulation of temporary files.

Output: Safety gate documentation, updated .gitignore, Make targets for safe cleanup operations.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/milestones/v1.3-ROADMAP.md
@.planning/research/STACK-testing-cleanup.md
@.gitignore
@Makefile
</context>

<tasks>

<task type="auto">
  <name>Create safety gate documentation</name>
  <files>.planning/phases/14-repository-cleanup/safety-gates.md</files>
  <action>
    Create safety-gates.md documenting cleanup validation procedures:

    ```markdown
    # Safety Gates for Repository Cleanup

    This document defines safety checks to prevent accidental removal of active code during repository cleanup operations.

    ## Before Any Cleanup Operation

    ### Gate 1: Git Status Check

    Verify workspace is clean before cleanup:

    ```bash
    git status --porcelain
    ```

    Expected output: Empty (no uncommitted changes)

    If files show as modified:
    - Review changes: git diff
    - Commit or stash changes before cleanup
    - Do NOT proceed with cleanup in dirty state

    Rationale: Cleanup should happen on clean baseline. Removes confusion about what files were changed by cleanup operations vs. existing uncommitted work.

    ### Gate 2: Test Baseline

    Verify tests pass before cleanup:

    ```bash
    pytest tests/ --fast --maxfail=1 -q
    ```

    Expected output: All tests pass (no failures)

    If tests fail:
    - Fix failing tests before cleanup
    - Document which tests are failing and why
    - Do NOT proceed with cleanup if baseline is broken

    Rationale: Cleanup should not be blamed for test failures that existed before cleanup. Establish known-good state.

    ### Gate 3: Import Validation

    Verify package imports work before cleanup:

    ```bash
    python -c "import analysis, api, pipeline; print('OK')"
    ```

    Expected output: No import errors

    If imports fail:
    - Fix import errors before cleanup
    - Check for missing dependencies
    - Do NOT proceed with cleanup if packages don't import

    Rationale: Ensures cleanup doesn't break on already-broken code.

    ## During Cleanup Operations

    ### Gate 4: Quiescent Check (for artifact removal)

    Before removing .pyc, __pycache__, or other artifacts:

    ```bash
    make dev-api &
    API_PID=$!
    sleep 5  # Wait for API to start

    # Run checks
    curl http://localhost:8000/health
    pytest tests/test_api_endpoints.py --fast

    # Stop API
    kill $API_PID
    ```

    Rationale: Ensure services aren't actively generating artifacts while we're cleaning.

    ### Gate 5: File Usage Check (for dead code deletion)

    Before deleting a function or class:

    ```bash
    grep -r "function_name_or_class_name" . --include="*.py" | grep -v "test_"
    ```

    Expected: Zero matches (not used in non-test code)

    If matches found:
    - Investigate usage (dynamic import, reflection, string-based imports)
    - Mark entry as MANUAL in dead-code-review.md
    - Do NOT delete without understanding usage

    Rationale: Code may be used dynamically (CLI, FastAPI routes, configuration files). Vulture can't detect all usage patterns.

    ## After Cleanup Operations

    ### Gate 6: Post-Cleanup Test Verification

    After each cleanup operation, verify tests still pass:

    ```bash
    pytest tests/ --fast --maxfail=1 -q
    ```

    If tests fail:
    - Review which tests failed
    - Check if failure is related to cleanup changes
    - Use git diff to see what changed
    - Revert cleanup if tests are broken by deletions

    Rationale: Immediate feedback on whether deletions broke functionality.

    ### Gate 7: Post-Cleanup Import Validation

    After removing code, verify imports still work:

    ```bash
    python -c "import analysis, api, pipeline; print('OK')"
    ruff check analysis api pipeline --select F401
    ```

    Expected: No import errors, no unused imports (Ruff F401)

    If errors appear:
    - Investigate missing imports
    - Check for cyclic import issues
    - Restore deleted code if needed

    Rationale: Ensures imports are still valid after deletions.

    ## Emergency Recovery

    ### Undo Deletions

    If cleanup broke something:

    ```bash
    git status                 # See what was deleted
    git checkout HEAD -- .     # Restore all deletions
    ```

    If you committed cleanup changes:
    ```bash
    git revert HEAD            # Revert last commit
    git log --oneline -5       # Find cleanup commit hash
    git revert <hash>         # Revert specific commit
    ```

    ### Test Coverage Rollback

    If coverage decreased unexpectedly:
    ```bash
    pytest --cov=analysis --cov=api --cov=pipeline --cov-report=term
    ```

    Compare to baseline coverage (88.95% from Phase 13):
    - If coverage dropped < 1%, acceptable variation
    - If coverage dropped > 1%, investigate and revert

    ## Best Practices

    1. **Commit after each major cleanup operation** (not after every single file)
    2. **Review git diff thoroughly** before committing deletions
    3. **Run tests frequently** during multi-file deletions
    4. **Keep review documents** (dead-code-review.md, deprecated-content-review.md) for reference
    5. **Document reasoning** for KEEP/DELETE decisions in review files
    6. **Never delete from dirty workspace** (commit or stash first)

    ## Cleanup Command Reference

    Safe cleanup operations with built-in gates:

    ```bash
    # Full cleanup (all gates)
    make clean

    # Step-by-step with gates
    git status                           # Gate 1: Clean workspace
    pytest tests/ --fast -q              # Gate 2: Test baseline
    pyclean .                            # Remove artifacts
    pytest tests/ --fast -q              # Gate 6: Test after cleanup
    git commit -m "chore: remove Python artifacts"  # Commit changes

    # Dead code cleanup with gates
    git status                           # Gate 1
    pytest tests/ --fast -q              # Gate 2
    vulture analysis/ api/ pipeline/     # Generate report
    # [Manual review in dead-code-review.md]
    # [Delete entries marked DELETE, one at a time]
    pytest tests/ --fast -q              # Gate 6 after each deletion
    git diff                             # Review deletions
    git commit -m "refactor: remove dead code"
    ```
    ```
  </action>
  <verify>test -s .planning/phases/14-repository-cleanup/safety-gates.md && grep -q "Gate 1: Git Status Check" .planning/phases/14-repository-cleanup/safety-gates.md</verify>
  <done>safety-gates.md documents 7 cleanup safety gates with commands and rationale</done>
</task>

<task type="auto">
  <name>Update .gitignore with comprehensive patterns</name>
  <files>.gitignore</files>
  <action>
    Update .gitignore to prevent future accumulation of temporary files. Add missing patterns (if not already present):

    Patterns to add (if missing):
    - # macOS
    - .DS_Store
    - .AppleDouble
    - .LSOverride

    - # Editor backup/swap files
    - *.swp
    - *.swo
    - *~
    - ._*  (macOS resource forks)

    - # Python cache
    - *.pyc
    - *.pyo
    - *.pyd
    - __pycache__/
    - .pytest_cache/

    - # Coverage
    - .coverage
    - .coverage.*
    - coverage.xml
    - coverage.json
    - htmlcov/

    - # Type checking
    - .mypy_cache/
    - .ruff_cache/

    - # Build artifacts
    - *.egg-info/
    - dist/
    - build/

    - # Environment
    - .venv/
    - venv/
    - ENV/
    - env/

    - # IDE
    - .vscode/
    - .idea/
    - *.sublime-*

    - # Logs
    - *.log

    Verify .gitignore already has patterns for:
    - *.pyc, __pycache__ (added in Plan 02)
    - .coverage, htmlcov (from existing)
    - .mypy_cache, .ruff_cache (from existing)
    - web/node_modules, web/.next (from existing)

    Organize sections logically (macOS, Python, Coverage, Build, IDE, etc.).
  </action>
  <verify>grep -q ".DS_Store" .gitignore && grep -q "*.swp" .gitignore && grep -q "*.log" .gitignore && grep -q ".vscode" .gitignore</verify>
  <done>.gitignore includes patterns for macOS, editor swap files, logs, Python cache, coverage, build artifacts, environment, and IDE</done>
</task>

<task type="auto">
  <name>Add cleanup targets to Makefile</name>
  <files>Makefile</files>
  <action>
    Add cleanup-related targets to Makefile for easy operation:

    ```makefile
    # Cleanup targets
    clean-pyc:
    @echo "Removing Python artifacts..."
    pyclean .
    @echo "Python artifacts removed"

    clean-imports:
    @echo "Removing unused imports..."
    autoflake --remove-all-unused-imports --recursive --in-place analysis/ api/ pipeline/
    @echo "Unused imports removed"

    clean-reports:
    @echo "Removing coverage reports and cache..."
    rm -rf htmlcov/
    rm -f .coverage .coverage.*
    rm -rf .pytest_cache/
    @echo "Reports cleaned"

    clean-build:
    @echo "Removing build artifacts..."
    rm -rf *.egg-info/ dist/ build/
    @echo "Build artifacts removed"

    clean-all: clean-pyc clean-imports clean-reports clean-build
    @echo "All cleanup operations complete"

    # Safety gate check
    check-clean:
    @echo "=== Safety Gate: Git Status ==="
    @git status --short
    @echo ""
    @echo "=== Safety Gate: Imports ==="
    @python -c "import analysis, api, pipeline; print('All packages import OK')"
    @echo ""
    @echo "=== Safety Gate: Quick Tests ==="
    @pytest tests/ --fast --maxfail=1 -q

    # Dead code scan (read-only, no deletions)
    scan-dead-code:
    @echo "Scanning for dead code (read-only)..."
    @vulture analysis/ api/ pipeline/ --min-confidence 90 --sort-by-size
    @echo ""
    @echo "To generate full report: vulture analysis/ api/ pipeline/ > vulture-report.txt"
    ```

    Add these targets after existing targets, before `.PHONY` line. Update `.PHONY` to include new targets:

    ```makefile
    .PHONY: dev-api dev-web test test-coverage lint format clean-pyc clean-imports clean-reports clean-build clean-all check-clean scan-dead-code
    ```

    Reference: safety-gates.md for cleanup command patterns.
  </action>
  <verify>grep -q "clean-pyc:" Makefile && grep -q "clean-all:" Makefile && grep -q "check-clean:" Makefile && grep -q "scan-dead-code:" Makefile</verify>
  <done>Makefile includes targets: clean-pyc, clean-imports, clean-reports, clean-build, clean-all, check-clean, scan-dead-code</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    - safety-gates.md: Documentation of 7 safety gates for cleanup operations
    - Updated .gitignore with comprehensive exclusion patterns
    - Makefile targets for safe cleanup operations (clean-pyc, clean-all, check-clean, scan-dead-code)
  </what-built>
  <how-to-verify>
    1. Review .planning/phases/14-repository-cleanup/safety-gates.md:
       - Check all 7 gates are documented with commands
       - Verify rationale is clear for each gate
       - Test emergency recovery commands work

    2. Review .gitignore:
       - Check patterns are organized by category (macOS, Python, etc.)
       - Verify no duplicate patterns
       - Ensure no important files are accidentally ignored (check git status)

    3. Test Makefile targets:
       - Run `make check-clean` - verify git status, imports, tests all pass
       - Run `make scan-dead-code` - verify dead code scan runs safely (read-only)
       - Run `make clean-pyc` - verify pyclean runs and cleans artifacts
       - Run `make clean-all` - verify all cleanup operations run without errors

    4. Test .gitignore patterns (if comfortable):
       - Create a .DS_Store file: `touch .DS_Store`
       - Run `git status` - should not show .DS_Store
       - Create a .pyc file: `touch foo.pyc`
       - Run `git status` - should not show foo.pyc

    If any test fails, fix the issue before approving:
       - Fix Makefile target syntax errors
       - Adjust .gitignore patterns if important files are ignored
       - Update safety-gates.md if commands don't work
  </how-to-verify>
  <resume-signal>Type "approved" when all safety gates and cleanup commands work correctly</resume-signal>
</task>

<task type="auto">
  <name>Run final cleanup verification</name>
  <files>/Users/dustinober/Projects/Crime Incidents Philadelphia/*</files>
  <action>
    Run comprehensive cleanup verification using all safety gates from safety-gates.md:

    Gate 1: Git Status Check
    ```bash
    git status --porcelain
    ```
    Expected: Empty (or only safety-gates.md, .gitignore, Makefile changes)

    Gate 2: Test Baseline
    ```bash
    pytest tests/ --fast --maxfail=1 -q
    ```
    Expected: All tests pass

    Gate 3: Import Validation
    ```bash
    python -c "import analysis, api, pipeline; print('OK')"
    ruff check analysis api pipeline --select F401 --quiet
    ```
    Expected: No errors, no unused imports

    Gate 6: Post-Cleanup Test (verification that cleanup didn't break anything)
    ```bash
    pytest tests/ --fast --maxfail=1 -q
    ```
    Expected: All tests pass (same as Gate 2 baseline)

    Gate 7: Import Validation verification
    ```bash
    python -c "import analysis, api, pipeline; print('OK')"
    ```
    Expected: All packages import successfully

    Document any issues found in verification report.
  </action>
  <verify>git status --porcelain| wc -l | awk '{exit $1 > 3}' && pytest tests/ --fast --maxfail=1 -q && python -c "import analysis, api, pipeline" 2>&1</verify>
  <done>All safety gates pass: git clean, tests pass, imports work, no unused imports</done>
</task>

</tasks>

<verification>
- safety-gates.md documents 7 safety gates with commands
- .gitignore includes comprehensive patterns for temporary files
- Makefile includes cleanup targets (clean-pyc, clean-all, check-clean, scan-dead-code)
- All safety gates pass (git clean, tests pass, imports work)
- Make targets execute correctly
- .gitignore patterns work (temp files not tracked)
</verification>

<success_criteria>
- Safety gate documentation complete and tested
- .gitignore excludes all temporary file types
- Makefile provides safe cleanup commands
- All safety gates validated and passing
- Ready for Phase 15 (Quality Validation & CI Integration)
</success_criteria>

<output>
After completion, create `.planning/phases/14-repository-cleanup/14-06-SUMMARY.md`
</output>
