---
phase: 14-repository-cleanup
plan: 05
type: execute
wave: 3
depends_on: [14-03, 14-04]
files_modified: [analysis/*.py, api/*.py, pipeline/*.py]  # May delete files
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Dead code entries reviewed and marked for action (keep/delete)"
    - "Deprecated files in scripts/, docs/, notebooks/ identified and removed"
    - "Manual review gates prevent accidental deletion of active code"
  artifacts:
    - path: ".planning/phases/14-repository-cleanup/dead-code-review.md"
      provides: "Manual review decisions on dead code"
      contains: "KEEP|DELETE|MANUAL"
    - path: ".planning/phases/14-repository-cleanup/deprecated-content-review.md"
      provides: "Review of deprecated files in docs/, scripts/, notebooks/"
      contains: "deprecated|removed|keep"
  key_links:
    - from: "vulture-report.txt"
      to: "dead-code-review.md"
      via: "Manual review and categorization"
      pattern: "KEEP|DELETE"
    - from: "deprecated-content-review.md"
      to: "Script/docs/notebook files"
      via: "Manual review and removal decisions"
      pattern: "rm|delete"
---

<objective>
Manual review and removal of dead code and deprecated content.

Purpose: Review vulture dead code report and deprecated content in scripts/, docs/, notebooks/ to identify code/files for removal. This plan requires human verification to prevent accidental deletion of active code.

Output: Dead code categorized (keep/delete/remove), deprecated content removed, documentation of review decisions.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/milestones/v1.3-ROADMAP.md
@.planning/phases/14-repository-cleanup/vulture-report.txt
@scripts/, @docs/, @notebooks/
</context>

<tasks>

<task type="auto">
  <name>Create dead code review template</name>
  <files>.planning/phases/14-repository-cleanup/dead-code-review.md</files>
  <action>
    Create dead-code-review.md template for manual review of vulture findings:

    ```markdown
    # Dead Code Review

    Generated: [timestamp]
    Source: vulture-report.txt (80% confidence), vulture-minimal.txt (90% confidence)

    ## Review Instructions

    For each unused code entry, categorize:
    - **KEEP**: Code is used but not detected by vulture (dynamic imports, test-only code, entry points)
    - **DELETE**: Code is truly unused and safe to remove
    - **MANUAL**: Needs further investigation before decision

    ## Analysis Functions

    ### [Function Name] - [file.py:line]
    - Vulture confidence: [80% or 90%+]
    - Category: KEEP/DELETE/MANUAL
    - Reason: [Why it's safe to delete or why it must be kept]
    - Action: [None/Delete manually/Add to tests]

    [Repeat for all functions]

    ## Analysis Classes

    ### [Class Name] - [file.py:line]
    - Vulture confidence: [80% or 90%+]
    - Category: KEEP/DELETE/MANUAL
    - Reason: [...]
    - Action: [...]

    ## Summary

    - Total entries reviewed: [N]
    - KEEP: [N] (reason: ...)
    - DELETE: [N] (reason: ...)
    - MANUAL: [N] (reason: ...)
    ```

    Populate template with entries from vulture-report.txt. For each entry, include file path and line number.
  </action>
  <verify>test -s .planning/phases/14-repository-cleanup/dead-code-review.md && grep -q "Analysis Functions" .planning/phases/14-repository-cleanup/dead-code-review.md</verify>
  <done>dead-code-review.md template created with vulture entries</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Dead code review template populated with vulture findings from analysis/, api/, and pipeline/</what-built>
  <how-to-verify>
    1. Review .planning/phases/14-repository-cleanup/dead-code-review.md
    2. Examine each unused code entry for:
       - Functions/classes that are genuinely never called (DELETE)
       - Functions/classes used in CLI, web app, or dynamic imports (KEEP)
       - Functions/classes used in tests but not main code (KEEP - add tests if needed)
       - artifact_manager.py, phase2_config_loader.py (legacy/deprecated - investigate)
    3. Mark each entry with KEEP/DELETE/MANUAL
    4. Provide brief reasoning for each decision
    5. Focus DELETE on 90% confidence entries first (vulture-minimal.txt)
    6. For MANUAL entries, note what investigation is needed

    Common reasons to KEEP:
    - Exported in __init__.py (like classify_crime_category, extract_temporal_features)
    - Used in CLI commands (typer)
    - Used in FastAPI routes (dynamic)
    - Entry points (main(), app)
    - Test-only utilities (test fixtures)

    Common reasons to DELETE:
    - Old migration code (phase2_config_loader.py)
    - Unused utility functions never called
    - Abandoned experimental features
  </how-to-verify>
  <resume-signal>Type "approved" when review complete, or describe issues with template</resume-signal>
</task>

<task type="auto">
  <name>Remove dead code marked for deletion</name>
  <files>analysis/*.py, api/*.py, pipeline/*.py</files>
  <action>
    Read dead-code-review.md and remove all entries marked DELETE:

    For each DELETE entry:
    1. Open the source file at the specified line number
    2. Find the function/class definition
    3. Remove the entire function/class (including docstring)
    4. Run tests to verify: pytest tests/ --fast --maxfail=1
    5. If tests fail, restore the function and mark as MANUAL

    Safety check: Before deleting each item, verify:
    ```bash
    grep -r "function_name_or_class_name" . --include="*.py" | grep -v "test_"
    ```

    If the function/class name appears in non-test code, it may be used dynamically. Mark as MANUAL.

    Commit deletions as atomic changes: Each deleted function/class should be verified with tests before moving to next.
  </action>
  <verify>pytest tests/ --fast --maxfail=1 -q && echo "Tests pass after dead code removal"</verify>
  <done>All DELETE entries removed from codebase, all tests pass</done>
</task>

<task type="auto">
  <name>Review deprecated content in scripts/, docs/, notebooks/</name>
  <files>scripts/*, docs/v1.0/*</files>
  <action>
    Review directories for deprecated content:

    **scripts/**:
    - Check for scripts related to v1.0/v1.2 features (benchmark_container_builds.sh, preset_calculator.py, etc.)
    - Identify scripts no longer used in current workflow
    - Check if scripts are called in Makefile or CI workflows

    **docs/v1.0/**:
    - Check if v1.0 documentation directory is still needed
    - v1.0 is complete - these docs may be archived or removed

    **docs/v1.1/**:
    - If exists, v1.1 is also complete - may be archived/removed

    **docs/** root:
    - DELIVERY_SUMMARY.md - v1.0 deliverable, may be deprecated
    - FORECASTING_SUMMARY.md - possibly outdated
    - NOTEBOOK_COMPLETION_REPORT.md - if notebooks are removed, this is obsolete
    - NOTEBOOK_QUICK_REFERENCE.md - if notebooks are removed, this is obsolete

    **notebooks/**:
    - Currently has only README.md - check if any notebooks remain
    - If notebooks are removed, clear this directory

    Create deprecated-content-review.md documenting findings and removal decisions:

    ```markdown
    # Deprecated Content Review

    ## scripts/ Directory

    ### [filename]
    - Status: [KEEP/DELETE/ARCHIVE]
    - Reason: [Why delete or keep]
    - Called from: [Makefile/CI/Manual]
    - Action: [None/Delete/Archive]

    ## docs/ Directory

    ### [filename]
    - Status: [KEEP/DELETE/ARCHIVE]
    - Reason: [...]
    - Action: [...]

    ## notebooks/ Directory

    ### [filename]
    - Status: [KEEP/DELETE/ARCHIVE]
    - Reason: [...]
    - Action: [...]

    ## Summary

    - Files reviewed: [N]
    - KEEP: [N]
    - DELETE: [N]
    - ARCHIVE: [N]
    ```
  </action>
  <verify>test -s .planning/phases/14-repository-cleanup/deprecated-content-review.md && grep -q "Summary" .planning/phases/14-repository-cleanup/deprecated-content-review.md</verify>
  <done>deprecated-content-review.md documents review of scripts/, docs/, notebooks/</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>deprecated-content-review.md with review findings for scripts/, docs/, notebooks/ directories</what-built>
  <how-to-verify>
    1. Review .planning/phases/14-repository-cleanup/deprecated-content-review.md
    2. For each DELETE entry, verify it's truly no longer needed:
       - Check Makefile: grep for script references
       - Check CI: .github/workflows/ if using GitHub Actions
       - Check docker-compose.yml: any script references?
       - Check if referenced in any active documentation
    3. Confirm v1.0/v1.1 docs can be archived or removed (v1.3 is current milestone)
    4. Confirm notebooks/ directory can be cleared (only README remains)
    5. Check if DELIVERY_SUMMARY.md should be kept historical record or removed

    Focus DELETE on:
    - v1.0/v1.1 docs (historical - can be archived if needed or removed)
    - Scripts not used in current workflow (Makefile, docker-compose, CI)
    - Completed milestone scripts (smoke-check productization scripts if no longer used)
  </how-to-verify>
  <resume-signal>Type "approved" to proceed with deletions, or describe files to keep</resume-signal>
</task>

<task type="auto">
  <name>Remove deprecated content</name>
  <files>scripts/*, docs/v1.0/*, docs/DELIVERY_SUMMARY.md, docs/FORECASTING_SUMMARY.md, docs/NOTEBOOK_*.md</files>
  <action>
    Read deprecated-content-review.md and remove all entries marked DELETE:

    For each DELETE file/directory:
    1. Remove with appropriate command:
       - File: rm docs/DELIVERY_SUMMARY.md
       - Directory: rm -rf docs/v1.0/ scripts/preset_calculator.py
    2. Run tests to verify: pytest tests/ --fast --maxfail=1
    3. If tests fail, restore the file and mark as MANUAL

    Safety: Use git status to check what's being deleted before committing.

    For docs/v1.0/ and docs/v1.1/:
    - If keeping historical record, archive to docs/archive/ instead of deleting
    - If deleting, verify no active documentation links to these docs

    Commit deletions as atomic changes. Each deleted file should be verified before moving to next.
  </action>
  <verify>pytest tests/ --fast --maxfail=1 -q && echo "Tests pass after deprecated content removal"</verify>
  <done>All deprecated files removed, all tests pass</done>
</task>

</tasks>

<verification>
- dead-code-review.md created and populated with vulture entries
- Review completed with KEEP/DELETE/MANUAL categorization
- All DELETE entries verified and removed from codebase
- deprecated-content-review.md documents findings
- Deprecated files removed after verification
- All tests pass after all removals
</verification>

<success_criteria>
- Dead code review completed with documented decisions
- All genuinely unused code removed
- Deprecated content in scripts/, docs/, notebooks/ removed/ archived
- All tests pass after cleanup
- Review documents preserved for future reference
</success_criteria>

<output>
After completion, create `.planning/phases/14-repository-cleanup/14-05-SUMMARY.md`
</output>
