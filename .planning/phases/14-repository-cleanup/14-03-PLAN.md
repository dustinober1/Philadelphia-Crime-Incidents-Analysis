---
phase: 14-repository-cleanup
plan: 03
type: execute
wave: 2
depends_on: [14-01]
files_modified: []
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Dead code report generated listing unused functions, classes, and variables"
    - "Report saved for manual review before any deletions"
    - "Report distinguishes between unused and untestable code"
  artifacts:
    - path: ".planning/phases/14-repository-cleanup/vulture-report.txt"
      provides: "Dead code analysis from vulture"
      contains: "unused code|dead code|unused function|unused class"
    - path: ".planning/phases/14-repository-cleanup/vulture-minimal.txt"
      provides: "High-confidence dead code (80%+ confidence)"
      contains: "unused"
  key_links:
    - from: "vulture"
      to: "vulture-report.txt"
      via: "vulture analysis/ api/ pipeline/ command"
      pattern: "analysis/|api/|pipeline/"
---

<objective>
Generate dead code report using vulture to identify unused functions, classes, and variables.

Purpose: Identify potentially unused code for manual review. Vulture works by static analysis, not runtime coverage, so it finds code that may never be called. Report will be reviewed in Plan 05 before any deletions.

Output: Dead code report file (vulture-report.txt) listing all identified unused code entities.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/milestones/v1.3-ROADMAP.md
@.planning/research/STACK-testing-cleanup.md
</context>

<tasks>

<task type="auto">
  <name>Generate comprehensive vulture dead code report</name>
  <files>analysis/*.py, api/*.py, pipeline/*.py</files>
  <action>
    Run vulture on all Python packages (analysis/, api/, pipeline/) to generate comprehensive dead code report:

    ```bash
    vulture analysis/ api/ pipeline/ --min-confidence 80 --sort-by-size > .planning/phases/14-repository-cleanup/vulture-report.txt 2>&1
    ```

    Command flags:
    - --min-confidence 80: Only report dead code with 80%+ confidence (reduces false positives)
    - --sort-by-size: Sort by code size (largest unused items first, most impact)
    - Redirect output to vulture-report.txt for manual review

    Vulture will analyze:
    - Functions: Functions that are never called
    - Classes: Classes that are never instantiated
    - Variables/Attributes: Variables that are never used

    This is static analysis (not runtime), so it may find:
    - True dead code (unused code that can be safely removed)
    - False positives (code called dynamically, via reflection, or not imported in test scope)
  </action>
  <verify>test -s .planning/phases/14-repository-cleanup/vulture-report.txt && grep -q "unused" .planning/phases/14-repository-cleanup/vulture-report.txt</verify>
  <done>vulture-report.txt exists, non-empty, and contains unused code entries</done>
</task>

<task type="auto">
  <name>Generate high-confidence dead code report</name>
  <files>analysis/*.py, api/*.py, pipeline/*.py</files>
  <action>
    Run vulture with higher confidence threshold (90%+) to identify most likely dead code:

    ```bash
    vulture analysis/ api/ pipeline/ --min-confidence 90 --sort-by-size > .planning/phases/14-repository-cleanup/vulture-minimal.txt 2>&1
    ```

    This report will have fewer entries but higher certainty. These are prime candidates for removal after manual review.

    Compare with comprehensive report (vulture-report.txt at 80% confidence) to understand the confidence spectrum.
  </action>
  <verify>test -s .planning/phases/14-repository-cleanup/vulture-minimal.txt && grep -q "unused" .planning/phases/14-repository-cleanup/vulture-minimal.txt</verify>
  <done>vulture-minimal.txt exists with high-confidence (90%+) dead code entries</done>
</task>

<task type="auto">
  <name>Document vulture analysis summary</name>
  <files>.planning/phases/14-repository-cleanup/vulture-report.txt, .planning/phases/14-repository-cleanup/vulture-minimal.txt</files>
  <action>
    Read both vulture reports and create a brief summary at the top of vulture-report.txt documenting:
    1. Total number of unused code entities found
    2. Breakdown by type (functions, classes, variables)
    3. Number of files affected
    4. Confidence levels used in analysis

    Summary format:
    ```
    ================================
    VULTURE DEAD CODE ANALYSIS SUMMARY
    ================================
    Analysis date: [current date]
    Packages analyzed: analysis/, api/, pipeline/

    -- 80% Confidence (comprehensive) --
    Total unused entities: [count]
    - Unused functions: [count]
    - Unused classes: [count]
    - Unused attributes/variables: [count]
    Files affected: [count]

    -- 90% Confidence (high-confidence) --
    Total unused entities: [count]
    Files affected: [count]

    [Original vulture output follows]
    ```

    Use grep/awk to parse the vulture reports and count occurrences of "unused" patterns.
  </action>
  <verify>grep -q "VULTURE DEAD CODE ANALYSIS SUMMARY" .planning/phases/14-repository-cleanup/vulture-report.txt && grep -q "Total unused entities" .planning/phases/14-repository-cleanup/vulture-report.txt</verify>
  <done>vulture-report.txt has analysis summary at the top with counts and breakdown</done>
</task>

</tasks>

<verification>
- vulture-report.txt exists and is non-empty
- vulture-minimal.txt exists and is non-empty
- Reports contain unused code entries
- Analysis summary is added to vulture-report.txt
- Both reports saved in .planning/phases/14-repository-cleanup/
</verification>

<success_criteria>
- Comprehensive dead code report generated (80% confidence)
- High-confidence dead code report generated (90%+ confidence)
- Summary statistics documented in reports
- Reports saved for manual review in Plan 05
</success_criteria>

<output>
After completion, create `.planning/phases/14-repository-cleanup/14-03-SUMMARY.md`
</output>
