---
phase: 04-dashboard-foundation
plan: 04
type: execute
wave: 2
depends_on: [04-01, 04-02]
files_modified:
  - dashboard/filters/geo_filters.py
  - dashboard/app.py
autonomous: true

must_haves:
  truths:
    - "User can filter dashboard by police district using multi-select"
    - "User can filter by geographic area (all districts or individual)"
    - "District options are limited to those with data in filtered time range"
    - "Filters sync to URL query parameters"
  artifacts:
    - path: "dashboard/filters/geo_filters.py"
      provides: "Geographic filter controls"
      min_lines: 100
      exports: ["render_geo_filters", "get_district_list_from_data"]
  key_links:
    - from: "dashboard/filters/geo_filters.py"
      to: "dashboard/components/cache.py"
      via: "Use apply_filters for filtering data by district"
      pattern: "from dashboard\\.components\\.cache import"
    - from: "dashboard/filters/geo_filters.py"
      to: "st.query_params"
      via: "Sync district filter state to URL"
      pattern: "st\\.query_params"
    - from: "dashboard/app.py"
      to: "dashboard/filters/geo_filters.py"
      via: "Import and use render_geo_filters in sidebar"
      pattern: "from dashboard\\.filters\\.geo_filters import"
---

<objective>
Implement geographic filter controls for police district selection with URL state synchronization.

Purpose: Enable users to filter dashboard data by police district (1-23) using multi-select controls. Filters persist in URL for shareable links. This addresses requirement DASH-02.

Output: Geographic filter module with district multi-select, "all districts" option, and URL sync.
</objective>

<execution_context>
@/Users/dustinober/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dustinober/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-dashboard-foundation/04-CONTEXT.md
@.planning/phases/04-dashboard-foundation/04-RESEARCH.md

@dashboard/config.py
@dashboard/components/cache.py
@dashboard/filters/time_filters.py
@analysis/categorical_analysis.py
</context>

<tasks>

<task type="auto">
  <name>Create geographic filter controls for district selection</name>
  <files>dashboard/filters/geo_filters.py, dashboard/app.py</files>
  <action>
Create geographic filter components for police district selection:

1. **CREATE dashboard/filters/geo_filters.py**:
```python
"""
Geographic filter controls for the dashboard.

Provides police district selection with URL state synchronization.
"""

import streamlit as st
from typing import NamedTuple

from dashboard.config import FILTER_DEFAULTS


class GeoFilterState(NamedTuple):
    """Immutable container for geographic filter state."""

    districts: list[int]
    select_all: bool


def read_geo_filters_from_url() -> dict:
    """
    Read geographic filter state from URL query parameters.

    Returns:
        Dict with districts key (comma-separated string or None for all).
    """
    params = st.query_params

    result = {"districts": None}  # None = all districts

    if "districts" in params:
        # Parse comma-separated districts
        districts_str = params["districts"]
        try:
            result["districts"] = [int(d) for d in districts_str.split(",")]
        except ValueError:
            # Invalid format, use default
            result["districts"] = None

    return result


def sync_geo_filters_to_url(state: GeoFilterState) -> None:
    """
    Sync geographic filter state to URL query parameters.

    Args:
        state: Current GeoFilterState to persist.
    """
    params = st.query_params

    if state.select_all:
        # Don't encode districts in URL (all districts = cleaner URL)
        if "districts" in params:
            del params["districts"]
    else:
        # Encode as comma-separated
        districts_str = ",".join(str(d) for d in sorted(state.districts))
        params["districts"] = districts_str


def get_district_list_from_data(df) -> list[int]:
    """
    Get list of districts that have data in the current DataFrame.

    Useful for limiting district options to those with data in the filtered
    time range.

    Args:
        df: Filtered DataFrame.

    Returns:
        Sorted list of district integers present in the data.
    """
    if "dc_dist" not in df.columns:
        return list(range(1, 24))  # All districts

    # Handle district values that may be strings or floats
    districts = df["dc_dist"].dropna().unique()

    # Convert to int, handling string values
    district_ints = []
    for d in districts:
        try:
            if isinstance(d, str):
                district_ints.append(int(float(d)))
            else:
                district_ints.append(int(d))
        except (ValueError, TypeError):
            continue

    return sorted(set(district_ints))


def render_geo_filters(df, key_prefix: str = "geo") -> GeoFilterState:
    """
    Render geographic filter controls in the sidebar.

    Creates:
    - Select all districts toggle
    - District multi-select (when not select all)
    - Reset button

    Args:
        df: Filtered DataFrame (used to limit district options).
        key_prefix: Prefix for widget keys to avoid conflicts.

    Returns:
        GeoFilterState with current filter values.

    Example:
        >>> geo_state = render_geo_filters(filtered_df)
        >>> geo_state.districts
        [1, 2, 3, 5, 7]
        >>> geo_state.select_all
        False
    """
    with st.sidebar:
        st.subheader(":map: Geographic Area")

        # Read from URL or default to all districts
        url_state = read_geo_filters_from_url()

        # Get available districts from data
        available_districts = get_district_list_from_data(df)

        # Select all toggle
        select_all = st.checkbox(
            "Select All Districts",
            value=(url_state["districts"] is None),
            key=f"{key_prefix}_select_all",
        )

        if select_all:
            # All districts selected
            selected_districts = available_districts
        else:
            # Default to URL state or available districts
            if url_state["districts"] is not None:
                # Filter to available districts
                default_districts = [d for d in url_state["districts"] if d in available_districts]
                if not default_districts:
                    default_districts = available_districts
            else:
                default_districts = available_districts

            selected_districts = st.multiselect(
                "Police Districts",
                options=available_districts,
                default=default_districts,
                format_func=lambda x: f"District {int(x)}",
                key=f"{key_prefix}_districts",
            )

            # Show "No districts selected" message
            if not selected_districts:
                st.warning("No districts selected. Showing all districts.")
                selected_districts = available_districts

        # Reset button
        if st.button(":recycle: Reset Geo Filters", key=f"{key_prefix}_reset"):
            if "districts" in st.query_params:
                del st.query_params["districts"]
            st.rerun()

    # Create state object
    state = GeoFilterState(
        districts=selected_districts,
        select_all=select_all,
    )

    # Sync to URL
    sync_geo_filters_to_url(state)

    return state


def get_filter_districts(state: GeoFilterState) -> list[int]:
    """
    Convert GeoFilterState to district list for filtering.

    Args:
        state: GeoFilterState from render_geo_filters.

    Returns:
        List of district integers.
    """
    return state.districts
```

2. **UPDATE dashboard/app.py** to integrate geo filters:
```python
"""
Philadelphia Crime Incidents Dashboard - Main Entry Point.

Run with: streamlit run dashboard/app.py
"""

import streamlit as st
from pathlib import Path

from dashboard.config import DISPLAY_CONFIG, PAGE_NAMES
from dashboard.components.cache import load_crime_data, get_data_summary, apply_filters
from dashboard.filters.time_filters import render_time_filters, get_filter_dates
from dashboard.filters.geo_filters import render_geo_filters, get_filter_districts

# Configure page
st.set_page_config(
    page_title="Philadelphia Crime Dashboard",
    page_icon=":police_car:",
    layout=DISPLAY_CONFIG["layout"],
    initial_sidebar_state="expanded",
)

# Custom CSS
def _load_custom_css():
    st.markdown("""
    <style>
    .main-header {
        font-size: 2.5rem;
        font-weight: 700;
        color: #1f77b4;
        margin-bottom: 0.5rem;
    }
    .sub-header {
        font-size: 1.2rem;
        color: #666;
        margin-bottom: 2rem;
    }
    </style>
    """, unsafe_allow_html=True)

def main():
    """Main dashboard entry point."""
    _load_custom_css()

    # Title
    st.title(DISPLAY_CONFIG["title"])
    st.markdown(f"<p class='sub-header'>{DISPLAY_CONFIG['subtitle']}</p>", unsafe_allow_html=True)

    # Load data (cached)
    with st.spinner("Loading data..."):
        df = load_crime_data()

    # Render time filters in sidebar
    time_state = render_time_filters()
    start_date, end_date = get_filter_dates(time_state)

    # Apply time filters first (to limit district options)
    df_time_filtered = apply_filters(df, start_date=start_date, end_date=end_date)

    # Render geo filters (district options limited by time range)
    geo_state = render_geo_filters(df_time_filtered)
    selected_districts = get_filter_districts(geo_state)

    # Apply both filters
    filtered_df = apply_filters(
        df,
        start_date=start_date,
        end_date=end_date,
        districts=selected_districts,
    )

    # Display summary stats
    summary = get_data_summary(filtered_df)

    st.subheader(f"Filtered Summary: {start_date} to {end_date}")

    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Records", f"{summary['total_records']:,}")
    with col2:
        st.metric("Years", summary.get('years', 'N/A'))
    with col3:
        st.metric("Districts", f"{len(selected_districts)} of {summary.get('districts', 'N/A')}")
    with col4:
        coord_pct = summary.get('coord_coverage', {}).get('percentage', 0)
        st.metric("Valid Coordinates", f"{coord_pct:.1f}%")

    # Show selected districts
    if len(selected_districts) < 23:
        st.caption(f":map: Districts: {', '.join(f'D{d}' for d in sorted(selected_districts))}")
    else:
        st.caption(":map: Districts: All 23 districts")

    st.caption(f":link: Share this view: URL encodes your current filter settings")

if __name__ == "__main__":
    main()
```

3. **VERIFY geo filters work**:
```bash
cd "/Users/dustinober/Projects/Crime Incidents Philadelphia"
python -c "
from dashboard.filters.geo_filters import (
    render_geo_filters, GeoFilterState, get_filter_districts,
    get_district_list_from_data, read_geo_filters_from_url
)
# Test state creation
state = GeoFilterState(districts=[1, 2, 3], select_all=False)
districts = get_filter_districts(state)
assert districts == [1, 2, 3], f'Expected [1, 2, 3], got {districts}'
print('Geo filters: state creation OK')
# Test all districts
all_state = GeoFilterState(districts=list(range(1, 24)), select_all=True)
assert len(all_state.districts) == 23
print('Geo filters: all districts OK')
print('Geo filters: module loaded successfully')
"
</verify>
```

Key implementation notes:
- Districts 1-23 represent Philadelphia Police Department districts
- District values may be stored as strings or floats in source data - convert to int
- Select all toggle simplifies selecting all 23 districts
- URL encoding: comma-separated districts (e.g., "1,2,3,5,7")
- When "select all" is true, don't encode districts in URL (cleaner)
- District options limited to those with data in current time filter
- Reset button clears districts from URL params
</action>
  <verify>
python -c "
from dashboard.filters.geo_filters import (
    GeoFilterState, get_filter_districts,
    read_geo_filters_from_url, sync_geo_filters_to_url
)
import streamlit as st
class MockQP(dict):
    def __init__(self):
        super().__init__()
        self._data = {}
    def __getitem__(self, key):
        return self._data.get(key)
    def __setitem__(self, key, value):
        self._data[key] = value
    def __contains__(self, key):
        return key in self._data
    def __delitem__(self, key):
        if key in self._data:
            del self._data[key]
st.query_params = MockQP()
# Test state
state = GeoFilterState(districts=[1, 2, 5], select_all=False)
districts = get_filter_districts(state)
assert districts == [1, 2, 5], f'Expected [1, 2, 5], got {districts}'
print('Geo filters verified')
"
</verify>
  <done>
GeoFilterState NamedTuple defined with districts list and select_all boolean

render_geo_filters() creates:
- Select all districts checkbox
- District multi-select (when not select all)
- Reset button

read_geo_filters_from_url() parses comma-separated districts from st.query_params

sync_geo_filters_to_url() writes district filter state to st.query_params

get_district_list_from_data() extracts unique districts from DataFrame, handling string/float conversion

get_filter_districts() converts GeoFilterState to district list

Updated app.py imports and uses render_geo_filters(), displays selected district count
</done>
</task>

</tasks>

<verification>
After completion:
1. Verify module imports: `python -c "from dashboard.filters.geo_filters import render_geo_filters, GeoFilterState, get_filter_districts"`
2. Verify GeoFilterState works with district lists
3. Verify app.py imports and uses geo filters: check for `render_geo_filters()` call
4. Test district list extraction from data: `python -c "from dashboard.components.cache import load_crime_data; from dashboard.filters.geo_filters import get_district_list_from_data; df = load_crime_data(); print(get_district_list_from_data(df))"`
5. Verify URL params are updated when filters change
</verification>

<success_criteria>
Geographic filter controls render in sidebar with select all toggle and district multi-select. Selecting "select all" shows all 23 districts. District multi-select allows individual district selection. URL parameters update with district selections. Summary stats show count of selected districts. District options are limited to those with data in filtered time range.
</success_criteria>

<output>
After completion, create `.planning/phases/04-dashboard-foundation/04-04-SUMMARY.md`
</output>
